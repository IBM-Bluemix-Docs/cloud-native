---

copyright:
  years: 2019
lastupdated: "2019-07-19"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# フォールト・トレランス
{: #fault-tolerance}

フォールト・トレランスとは、部分的な障害が発生した場合に稼働を継続するためのシステムの機能です。耐障害性のあるシステムの構築には、そのシステム内のすべてのサービスに要件が課されます。 クラウド環境の動的性質上、予期しない状況を想定し、そのような状況に正常に対応するようにサービスを作成する必要があります。 

通常、フォールト・トレランスのソリューションでは、タイムアウト、フォールバック、バルクヘッド、および回路ブレーカーに焦点を当てます。

一部の環境では、インフラストラクチャーのコンポーネント (Istio など) がフォールト・トレランスのメカニズムを備えていることがあります。 インフラストラクチャーの機能を利用できるかどうかにかかわらず、サービスは、リモート呼び出しが失敗する可能性があることを想定して、適切なフォールバック・アクションを準備しておく必要があります。

## タイムアウト

部分的な障害に対する最初の防御線として、タイムアウトを使用します。 タイムアウトによって、バッキング・サービスが無応答状態のときに、アプリケーションがエラーを受け取り、適切なフォールバック動作を実行してその状態に対処できるようになります。 タイムアウトは、必ずしも、要求された操作が失敗したことを意味するわけではありません。タイムアウトは、要求を行ったクライアントが応答を待つ時間を変更するものです。ターゲット・サービスの処理動作には影響しません。

多くの言語ライブラリーでは、デフォルトの要求タイムアウトが使用されています。Istio も同様です。 デフォルトでは、サイドカー・プロキシーは応答を 15 秒以内に受け取らないと、要求を中止します。 この値を変更するには、VirtualService 定義にルートのタイムアウト・ポリシーを設定します。例として、株価を返すサービスを使用すると、以下のような設定になります。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: stock-quote-service
spec:
  hosts:
  - 'stock-quote-service'
  http:
  - route:
    - destination:
        host: stock-quote-service
    timeout: 30s
```
{: codeblock}

サイドカー・プロキシーまたは Ingress ゲートウェイを経由して株価サービスに対して実行された要求は、デフォルト値の 15 秒ではなく、30 秒待機した後に失敗します。

この方法でタイムアウトを調整すると、この経路を使用しているすべての要求にタイムアウトが適用されます。これは、Istio が提供する基本的な保護層です。アプリケーションのフレームワークやライブラリーでタイムアウトを適用していなくても、Istio によって適用されるので、永遠に待機することはありません。ただし、アプリケーション・レベルのタイムアウトも適用されます。株価サービスのインフラストラクチャー・レベルのタイムアウトを 30 秒に延長しました。アプリケーション・ライブラリーでタイムアウトを 5 秒に設定した場合、アプリケーションの要求はこのタイムアウトで失敗します。

## フォールバック

アプリケーションに、バッキング・サービスへの要求が失敗した場合の処理を定義します。選択肢はいくつかありますが、目標は、これらのサービスが時間内に応答しない場合に正常に縮退実行することです。 リモート・サービスに障害が起きた場合は、要求を再試行すること、別の要求を試すこと、代わりにキャッシュ・データを返すことができます。

要求を再試行するのは、一見すると、最も簡単なフォールバック・メカニズムです。 しかし実は、要求を再試行すると、システム障害の連鎖発生 ([thundering herd 問題](https://en.wikipedia.org/wiki/Thundering_herd_problem)の一種である「再試行の嵐」) を招く恐れがあります。 アプリケーション・レベルのコードではシステムやネットワークの正常性を十分に認識できないため、指数関数的なバックオフ・アルゴリズムを正常に機能させるのは難しいことです。

Istio は、はるかに効率的に再試行を実行できます。 これは既に要求のルーティングに直接関与していて、言語に依存しない一貫した、再試行ポリシーの実装を提供します。 例えば、株価サービスには以下のようなポリシーを定義できます。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: stock-quote-service
spec:
  hosts:
  - 'stock-quote-service'
  http:
  - route:
    - destination:
        host: stock-quote-service
    retries:
      attempts: 3
      perTryTimeout: 5s
```
{: codeblock}

この単純な構成では、Istio サイドカー・プロキシーまたは Ingress ゲートウェイを経由して株価サービスに対して実行された要求は、最大 3 回試行されます。各試行について 5 秒のタイムアウトが設定されます。さらに、[追加のルート・マッチング・ルール](https://istio.io/docs/reference/config/networking/#HTTPMatchRequest)を設定して、この再試行ポリシーを例えば `GET` 要求に制限することもできます。

この設定には見落としやすい点があります。再試行間隔が指定されていないという点です。 再試行間隔はサイドカーが決定し、過負荷のサービスに処理が集中するのを避けるために、意図的に試行間隔にジッターを生じさせます。

<!-- Notes about other approaches here: -->

## バルクヘッド
{: #bulkheads-fault-tolerance}

バルクヘッドとは、船舶において 1 区画で発生した水漏れによって船全体が沈まないようにするための隔壁のことです。 このパターンは、同じような目的を達成するためにクラウド環境内で適用されていて、さまざまな方法で実施されています。

Java のようなマルチスレッド言語では、内部バルクヘッドを内部で使用し、キューまたはセマフォーのメカニズムによって、リモート・リソースとの通信に使用するリソースを制限または制御できます。

- キューを使用する場合は、サービスが特定のキューに特定数のスレッドを関連付けます。 キューが満杯になった後に実行された要求は、ただちに失敗を受け取ります。例えば、Java では `ThreadPoolExecutor` に `BlockingQueue` を関連付けます。
- セマフォーのメカニズムは、一定数の許可を使用することで機能します。 アウトバウンド要求は許可を必要とします。 要求が正常に実行されると、その許可は解放されて他の要求に使用されます。

また、次の例のように Istio の DestinationRule を使用して、アップストリーム・サービスの接続プールを制限するサービス間バルクヘッドを定義することもできます。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: stock-quote-service
spec:
  host: stock-quote-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 10
        connectTimeout: 30s
```
{: codeblock}

この構成では、株価サービスの各インスタンスに対して確立される同時接続の最大数が 10 に制限されます。30 秒以内に接続を確立できないサービスは、`503 -- Service Unavailable` 応答を受け取ります。このようなバルクヘッドを使用して、例えば、計算負荷の高いサービスが、対応できる数以上の要求を受け取るのを防ぐことができます。

## 回路ブレーカー

回路ブレーカーは、障害が発生したときにアウトバウンド要求の動作を最適化するために使用します。 応答しないサービスに対して繰り返し要求を実行するのではなく、回路ブレーカーは、一定の期間内に発生する障害の数を観測します。エラー率がしきい値を超えると、回路ブレーカーは回路を開放して要求を中止し、回路が再び閉じられるまで、それ以降のすべての要求を中止します。

回路ブレーカーは以下のように、Istio の DestinationRule を使用して定義することもできます。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: stock-quote-service
spec:
  host: stock-quote-service
  trafficPolicy:
    outlierDetection:
      consecutiveErrors: 3
      interval: 5s
      baseEjectionTime: 5m
      maxEjectionPercent: 100
```
{: codeblock}

この構成では、他のサービスが株価サービスに対して実行している要求に制約を設定します。 指定した `outlierDetection` トラフィック・ポリシーは個々のインスタンスに適用されます。 上記の構成を文章で表すと、「5 秒間隔で 3 回失敗した stock-quote-service インスタンスを少なくとも 5 分間排出する。最大ですべてのインスタンスを排出できる」となります。後半の `maxEjectionPercent` 設定はロード・バランシングに関する設定です。 Istio はロード・バランシング・プールを維持しており、失格したインスタンスをそのプールから排出します。 デフォルトでは、すべての有効なインスタンスの最大 10% をロード・バランシング・プールから排出します。

他の回路ブレークのメカニズムに詳しいユーザーから見ると、Istio にはハーフ・オープン状態がありません。 単純な計算が適用されます。インスタンスがプールから排出された状態が続く時間は、`baseInjectionTime * <そのインスタンスが排出された回数>` になります。これにより、一時的な障害からインスタンスを復旧し、問題のあるインスタンスをプールの外に排出した状態を維持することができます。

このように設定すると、株価サービスの同時呼び出しの最大数が 10 に制限されます。制限数を超えると、`503 -- Service Unavailable` 応答を受け取ります。

### Istio -- 速度制限
{: #istio-rate-limits}

Istio で**速度制限**を定義することもできます。これはバルクヘッドに似ていますが、同時に処理される並列呼び出し数を制限するだけではなく、時間枠も定義します。

例えば、許可するツイート数を 1 秒あたり 1 つのみにするとします。これは実際の例です。Twitter は、過去に Stock Trader に対する負荷テストを実行したときに `@IBMStockTrader` アカウントを自動的にロックしたことがあります。

<!-->
*<Need example.Note that rate limits require us to introduce the concept of Mixer Adapters, like memquota or redisquota; there's more to them than the earlier policies.>*


## テスト: Istio による障害注入

障害に対するコードの反応を調べるために、Istio を使用して意図的に障害を発生させることができます。
-->
