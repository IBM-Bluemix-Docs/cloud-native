---

copyright:
  years: 2019
lastupdated: "2019-02-11"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# フォールト・トレランス
{: #fault-tolerance}

フォールト・トレランスとは、部分的な障害が発生した場合に稼働を継続するためのシステムの機能です。 耐障害性のあるシステムを構築できるかどうかは、システム内部のすべてのサービスにかかっています。 クラウド環境は動的な性質を持つため、不良なデータを受け取ったり、必要なバッキング・サービスにアクセスできなかったり、分散システムでの同時更新で発生した競合を処理したりするなど、予期しない状況を想定して正常に対処できるようにサービスを作成する必要があります。 

通常、フォールト・トレランスのソリューションでは、タイムアウト、フォールバック、バルクヘッド、および回路ブレーカーに焦点を当てます。

一部の環境では、インフラストラクチャーのコンポーネント (Istio など) がフォールト・トレランスのメカニズムを備えていることがあります。 インフラストラクチャーの機能を利用できるかどうかにかかわらず、サービスは、リモート呼び出しが失敗することを前提として適切なフォールバック・アクションを準備しておく必要があります。

## タイムアウト

部分的な障害に対する最初の防御線として、タイムアウトを使用します。 タイムアウトによって、バッキング・サービスが無応答状態のときに、アプリケーションがエラーを受け取り、適切なフォールバック動作を実行してその状態に対処できるようになります。 タイムアウトは、必ずしも、要求された操作の失敗を意味するわけではありません。 タイムアウトは、要求を作成したクライアントが応答を待つ時間を変更するものです。ターゲット・サービスの処理動作には影響しません。

多くの言語ライブラリーでは、デフォルトの要求タイムアウトが使用されています。Istio も同様です。 デフォルトでは、サイドカー・プロキシーが応答を 15 秒以内に受け取らないと、要求を中止します。 この値を変更するには、VirtualService 定義にルートのタイムアウト・ポリシーを設定します。例として、株価を返すサービスを使用すると、以下のような設定になります。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: stock-quote-service
spec:
  hosts:
  - 'stock-quote-service'
  http:
  - route:
    - destination:
        host: stock-quote-service
    timeout: 30s
```
{: codeblock}

この構成では、サイドカー・プロキシーまたは Ingress ゲートウェイを経由して株価サービスに対して実行された要求は、デフォルト値の 15 秒ではなく、30 秒待機した後に要求を中止します。

このようにタイムアウトを調整するうえで興味深いのは、このルートを使用するすべての要求にタイムアウトが適用されることです。 これは、Istio が提供する基本的な保護層です。アプリケーションのフレームワークやライブラリーでタイムアウトを適用していなくても、Istio によって適用されるので、永遠に待機することはありません。 ただし、アプリケーション・レベルのタイムアウトも適用されます。 上記の例で、株価サービスのインフラストラクチャー・レベルのタイムアウトを 30 秒に延長したとします。 もしアプリケーション・ライブラリーでタイムアウトを 5 秒に設定した場合、アプリケーションの要求はタイムアウトで失敗します。

## フォールバック

アプリケーションには、バッキング・サービスへの要求が失敗した場合の処理を定義しておく必要があります。 選択肢はいくつかありますが、目標は、これらのサービスが時間内に応答しない場合に正常に縮退実行することです。 リモート・サービスに障害が起きた場合は、要求を再試行する、別の要求を試す、代わりにキャッシュ・データを返すことができます。

要求を再試行するのは、一見すると、最も簡単なフォールバック・メカニズムです。 しかし実は、要求を再試行すると、システム障害の連鎖発生 ([thundering herd 問題](https://en.wikipedia.org/wiki/Thundering_herd_problem)の一種である「再試行の嵐」) を招く恐れがあります。 アプリケーション・レベルのコードではシステムやネットワークの正常性を十分に認識できないため、指数関数的なバックオフ・アルゴリズムを正常に機能させるのは難しいことです。

Istio は、はるかに効率的に再試行を実行できます。 既に要求のルーティングに直接関係しており、言語に依存しない一貫した方法で再試行ポリシーを実装します。 例えば、株価サービスには以下のようなポリシーを定義できます。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: stock-quote-service
spec:
  hosts:
  - 'stock-quote-service'
  http:
  - route:
    - destination:
        host: stock-quote-service
    retries:
      attempts: 3
      perTryTimeout: 5s
```
{: codeblock}

この単純な構成では、Istio サイドカー・プロキシーまたは Ingress ゲートウェイを経由して株価サービスに対して実行された要求は、最大 3 回試行され、各試行に 5 秒のタイムアウトが設定されます。 さらに、[追加のルート・マッチング・ルール](https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPMatchRequest)を設定して、この再試行ポリシーを例えば `GET` 要求に制限することもできます。

この設定には見落としやすい点があります。再試行間隔が指定されていないという点です。 再試行間隔はサイドカーが決定し、過負荷のサービスに処理が集中するのを避けるために、意図的に試行間隔にジッターを生じさせます。

## バルクヘッド

バルクヘッドとは、船舶において 1 区画で発生した水漏れによって船全体が沈まないようにするための隔壁のことです。 同じような目的を達成するために、このパターンがクラウド環境にも適用されている点がいくつかあります。

Java のようなマルチスレッド言語では、内部バルクヘッドを内部で使用し、キューまたはセマフォーのメカニズムによって、リモート・リソースとの通信に使用するリソースを制限または制御できます。

- キューを使用する場合は、サービスが特定のキューに特定数のスレッドを関連付けます。 キューが満杯になった後に実行された要求は、ただちに失敗を受け取ります。 例えば、Java で `ThreadPoolExecutor` に `BlockingQueue` を関連付けることに相当します。
- セマフォーのメカニズムは、一定数の許可を使用することで機能します。 アウトバウンド要求は許可を必要とします。 要求が正常に実行されると、その許可は解放されて他の要求に使用されます。

また、次の例のように Istio の DestinationRule を使用して、アップストリーム・サービスの接続プールを制限するサービス間バルクヘッドを定義することもできます。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: stock-quote-service
spec:
  host: stock-quote-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 10
        connectTimeout: 30s
```
{: codeblock}

この構成では、株価サービスの各インスタンスに対して実行される同時接続の最大数が 10 に制限されます。30 秒以内に接続を作成できないサービスは、「`503 -- サービス利用不可`」応答を受け取ります。 このようなバルクヘッドを使用して、例えば、計算負荷の高いサービスが、対応できる数以上の要求を受け取るのを防ぐことができます。

## 回路ブレーカー

回路ブレーカーは、障害が発生したときにアウトバウンド要求の動作を最適化するために使用します。 応答しないサービスに対して繰り返し要求を実行するのではなく、回路ブレーカーは、一定の期間内に発生した障害の数を観測します。 エラー率がしきい値を超えると、回路ブレーカーは回路を開放して要求を中止し、回路が再び閉じられるまで、それ以降のすべての要求を中止します。

回路ブレーカーは、Istio の DestinationRule を使用して定義することもできます。

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: stock-quote-service
spec:
  host: stock-quote-service
  trafficPolicy:
    outlierDetection:
      consecutiveErrors: 3
      interval: 5s
      baseEjectionTime: 5m
      maxEjectionPercent: 100
```
{: codeblock}

この構成では、他のサービスが株価サービスに対して作成している要求に制約を設定します。 指定した `outlierDetection` トラフィック・ポリシーは個々のすべてのインスタンスに適用されます。 上記の構成を文章で表すと、「5 秒間隔で 3 回失格した stock-quote-service インスタンスを少なくとも 5 分間排出する。最大ですべてのインスタンスを排出できる」となります。後半の `maxEjectionPercent` 設定はロード・バランシングに関する設定です。 Istio はロード・バランシング・プールを維持しており、失格したインスタンスをそのプールから排出します。 デフォルトでは、すべての有効なインスタンスの最大 10% をロード・バランシング・プールから排出します。

他の回路ブレークのメカニズムに詳しいユーザーから見ると、Istio にはハーフ・オープン状態がありません。 代わりに、単純な計算が適用され、インスタンスがプールから排出された状態が続く時間は、`baseInjectionTime * <そのインスタンスが排出された回数>` になります。 これにより、障害が起きたインスタンスを一貫した方法でプールの外に出し、一時的な障害からインスタンスを復旧することができます。

