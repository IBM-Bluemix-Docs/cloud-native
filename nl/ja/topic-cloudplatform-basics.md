---

copyright:
  years: 2019
lastupdated: "2019-02-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# クラウド・プラットフォームの概念
{: #platform}

このセクションでは、開発者がコンテナー、Kubernetes、Helm、および Istio を使用してクラウド・ネイティブ・アプリケーションを作成するときに関係する中核となるテクノロジーと概念について簡単に概要を説明します。
{:shortdesc}

## コンテナー
{: #containers}

コンテナーは、アプリケーションとそのすべての依存関係を自己完結型の 1 つの単位としてパッケージ化するための標準的なメカニズムです。 コンテナーはポータビリティーの問題を解決します。コンテナー成果物 (イメージ) によって、アプリケーションを実行するために必要なものすべてを適切な場所に確実に配置できます。そして、コンテナー・エンジンは、効率的で安全な保護された方法でコンテナーを独立したプロセスとして実行することに集中できます。

通常、コンテナー・イメージは、`Dockerfile` に定義した命令のリストからビルドされます。 ほとんどの場合、コンテナー・イメージは他のコンテナー・イメージからビルドされます (基本的に、既知の以前の状態の命令に続けて指定するため)。 例えば、以下のスニペットを使用して、独自の Open Liberty イメージを作成できます。

```yaml
FROM open-liberty:kernel
COPY server.xml /config/
```
{: codeblock}

イメージをビルドしたら、イメージを実行できます。 Docker や [containerd](https://containerd.io/){: new_window} ![外部リンクのアイコン](../icons/launch-glyph.svg "外部リンクのアイコン") などのコンテナー実行エンジンが、そのイメージ定義を受け取り、定義されたエントリー・ポイントをリソースを分離したプロセスとしてホスト・オペレーティング・システム上で直接実行するので、仮想マシンのオーバーヘッドは発生しません。

コンテナー・イメージは*レジストリー* に保管されます。 最もよく知られているのはパブリック Docker Hub レジストリーですが、通常は、ご使用のインフラストラクチャーおよび CI/CD パイプラインとより密接に関連付けられている {{site.data.keyword.registryshort_notm}} などのアクセス制御コンテナー・レジストリーとの間でイメージをプッシュしたりプルしたりします。

## Kubernetes
{: #kubernetes}

IBM のクラウド・プラットフォームはコンテナー・オーケストレーションに Kubernetes を利用しています。 そのため、コンテナーの基礎を理解することに加え、Kubernetes の基本コマンドやデプロイメント成果物などを含む Kubernetes の基礎を理解することも開発者にとって重要になります。 以下の表に、重要な Kubernetes 概念の一部を示します。

| 概念 | 説明 |
|---------|-------------|
| ポッド | 一緒にデプロイするコンテナーを 1 つの単位としてまとめたグループです。 ポッドはどちらかといえば変更不可能で、ポッドのさまざまな属性を変更するには元のポッドを置き換える必要があります。 標準的なアプリケーションは、中核のビジネス・ロジックを含むコンテナー 1 つと、ポッドの細かいレベルでプラットフォーム機能を提供するオプションの追加ポッドで構成されます。 |
| デプロイメント | ステートレスなポッドのための繰り返し実行可能なテンプレートであり、ポッドの概念にスケールという側面を追加します。 また、テンプレート化された定義を更新したり、基礎となるポッド・インスタンスを置換したりできます。 Kubernetes のデプロイメント構成は Kubernetes デプロイメント・コントローラーによってモニターされ、指定のデプロイメントに対して宣言された数のポッドが維持されていることが確認されます。 デプロイメントは `.yaml` ファイルで `kind: Deployment` と表示されます。 |
| サービス | 比較的に不安定なポッド IP アドレスのセットを表す既知の名前。 サービスは、クラスター・プライベート・ネットワークにのみ存在することも、外部に公開することもできます (これは通常はクラウド・プロバイダー固有のロード・バランサーを使用して行います)。 サービスは、`.yaml` ファイルで `kind: Service` と表示されます。 |
| Ingress | 仮想ホスティングまたは状況に応じたルーティングによって、複数のサービスで 1 つのネットワーク・アドレスを共有できるようにします。 また、Ingress は TLS 終端などのネットワーク接続管理アクティビティーも実行できます。 Ingress は、`.yaml` ファイルで `kind: Ingress` と表示されます。 |
| シークレット | ポッド・ランタイムで使用する機密情報を格納し、コンテナー・イメージまたはオーケストレーションからデプロイメント固有の情報を分離するオブジェクト。 シークレットは、環境変数または仮想ファイル・システム・マウントによって実行時にポッドに公開できます。 シークレットを使用しない場合、機密情報はコンテナー・イメージまたはオーケストレーションに格納されます。どちらの場合も、予期せず情報が漏えいしたり、意図せずアクセスされたりする可能性が高くなります。 |
| ConfigMap | デプロイメント固有の情報をコンテナー・オーケストレーションから分離するという点ではシークレットと同じ役割を果たします。 ただし、ConfigMap は汎用的な構成構造です。 ポッドのコンテナーとシステム・コンポーネントに実行時に情報 (コマンド・ライン引数、環境変数、他の構成成果物など) をバインドするために使用します。 | 

すべてのリソースは Kubernetes リソース・モデルで定義されています。リソース・モデルは、RESTful API、または `kubectl` コマンド・ラインを介して送信される構成ファイルによって構成できます。

詳しくは、[Kubernetes の基礎](https://kubernetes.io/docs/tutorials/kubernetes-basics/){: new_window} ![外部リンクのアイコン](../icons/launch-glyph.svg "外部リンクのアイコン")、[Kubernetes オブジェクト・モデル](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/)![外部リンクのアイコン](../icons/launch-glyph.svg "外部リンクのアイコン")、および [`kubectl` コマンド・ライン](https://kubernetes.io/docs/reference/kubectl/overview/){: new_window} ![外部リンクのアイコン](../icons/launch-glyph.svg "外部リンクのアイコン") を参照してください。 

## Helm
{: #helm}

Helm は、Kubernetes 用に作成されたソフトウェアを簡単に見つけて、共有、使用できるパッケージ・マネージャーです。 また、Helm は同一のアプリケーションを複数の環境にデプロイするというユーザーの一般的なニーズにも応えます。 Helm では*チャート* を使用します。チャートは、インストール時に有効な Kubernetes オブジェクト (YAML) を生成するテンプレートのコレクションです。 これらのチャートは、テンプレート言語で作成されています。テンプレート言語では、変数、範囲操作など Kubernetes デプロイメント・メタデータの保守作業を簡単にしてくれる操作を使用できます。

詳しくは、[Helm](https://helm.sh/){: new_window} ![外部リンクのアイコン](../icons/launch-glyph.svg "外部リンクのアイコン") を参照してください。

## Istio サービス・メッシュ
{: #istio}

Istio は、マイクロサービスを管理および保護するためのオープン・ソース・プラットフォームです。 Kubernetes などのオーケストレーターと連携して、サービス間の通信を管理および制御します。

Istio はサイドカー・モデルを使用して機能します。 サイドカー (Envoy Proxy) とは、アプリケーションと一緒に配置される独立したプロセスです。 サイドカーはサービスの受信と発信のすべての通信を管理し、サービスの作成に使用されたプログラミング言語やフレームワークによらずに、すべてのサービスに共通のレベルの機能を適用します。 つまり、Istio のメカニズムでは、ルーティングとセキュリティーのポリシーを一元的に構成する一方で、それらのポリシーをサイドカーを利用して分散的に適用します。

ほとんどの場合、個々のプログラミング言語やフレームワークで提供されている同様の機能ではなく、Istio で提供されている機能を使用することをお勧めします。 例えば、ロード・バランシングや他のルーティング・ポリシーは、インフラストラクチャーのほうが一貫した方法で定義、管理、および適用できます。

分散トレースなどの一部のケースでは、Istio とアプリケーション・レベルのライブラリーが補完し合います。 両方を一緒に使用すると、操作を向上できます。 分散トレースについては、Istio はトレース・ヘッダーの存在のみを確認しますが、アプリケーション・ライブラリーは要求間の関係に関する重要な状況情報を提供できます。 Istio と補助的なライブラリーまたはフレームワーク・ライブラリーの両方を一緒に使用すると、システム全体の理解が深まります。

非常に大まかにいうと、Istio は、管理の概念、可視性、セキュリティーを強化するために Kubernetes プラットフォームを拡張します。 Istio の機能は、以下の 4 つのカテゴリーに分けることができます。

* トラフィック管理: トラフィックの分割、障害リカバリー、カナリア・リリースを実行するためにマイクロサービス間のトラフィックを制御します。
* セキュリティー: マイクロサービス間で強い ID ベースの認証、許可、暗号化を利用可能にします。
* 可観測性: クラスターで実行されるアプリケーションの可視性を向上させるためにメトリックとログを収集します。
* ポリシー: アプリケーションを保護するためにアクセス制御、速度制限、割り当て量を適用します。

詳しくは、[What is Istio?](https://istio.io/docs/concepts/what-is-istio/){: new_window} ![外部リンクのアイコン](../icons/launch-glyph.svg "外部リンクのアイコン") を参照してください。



