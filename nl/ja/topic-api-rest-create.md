---

copyright:
  years: 2019
lastupdated: "2019-04-30"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# RESTful マイクロサービスの作成
{: #rest-api}

クラウド・ネイティブ・アプリケーションでは、マイクロサービス・アーキテクチャーであるかどうかにかかわらず、API を生成し、利用します。 API には、内部 (またはプライベート) API と見なされるものと、外部 API と見なされるものがあります。 
{:shortdesc}

内部 API は、バックエンド・サービス間の相互通信のために、ファイアウォールで保護された環境内でのみ使用されます。 外部 API は、利用者に統一エントリー・ポイントを提供します。また、多くの場合、速度制限やその他の使用制限を適用できる {{site.data.keyword.apiconnect_long}} などのツールで**管理**されます。 このような API の例には、[GitHub Developer API](https://developer.github.com/v3/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") があります。 ここでは、内部実装の詳細を公開せずに、HTTP の動詞、戻りコード、ページ表示動作などの使用方法が一貫した 1 つの統一 API が提供されています。 この API の裏側にあるのは、モノリシックの 1 つのアプリケーションかもしれませんし、マイクロサービスの集合かもしれません。詳細を利用者に公開していないので、GitHub は必要なときに自由に内部システムを進化させることができるわけです。

## RESTful API のベスト・プラクティス
{: #bps-apis}

REST API では、べき等な操作 (安全に複数回実行できる操作) であるかどうかに特に注意しながら、標準の HTTP 動詞を使用して作成、取得、更新、削除 (CRUD) 操作を行うようにする必要があります。

* POST 操作は、リソースを作成または更新するために使用できます。 POST 操作を繰り返し呼び出してはいけません。 例えば、POST 要求でリソースを作成する場合に、複数回呼び出すと、呼び出すたびに新しい固有のリソースが作成されます。
* GET 操作は、繰り返し呼び出せる必要がありますが、副作用を与えてはいけません。 情報取得のためにのみ使用する必要があります。 照会パラメーターを指定した GET 要求で、情報を変更したり、更新したりしてはいけません。 代わりに、POST、PUT、または PATCH 操作を使用してください。
* PUT 操作は、リソースを更新するために使用できます。 通常、PUT 操作では、更新するリソースの完全なコピーを指定するので、この操作は複数回呼び出せます。
* PATCH 操作は、リソースを部分的に更新できます。 差分を指定する方法、およびリソースに適用する方法によっては、繰り返し呼び出せます。 例えば、A から B に値を変更することを指定した PATCH 操作は、繰り返し呼び出せます。 複数回呼び出しても、値が既に B であれば、何も効果はありません。
* DELETE 操作は複数回呼び出せます。リソースは 1 回だけで削除できるからです。 ただし、戻りコードは変わります。最初の操作は成功(`200` または `204`) しますが、2 回目以降の呼び出しではリソースが見つからない (`404` または `410`) からです。

### 機械で解釈しやすい記述的な結果
{: #rest-results}

API を呼び出すのは人ではなくソフトウェアであるという考えに立ち、可能な限り効果的かつ効率的な方法で、呼び出し元に情報を渡すように注意する必要があります。

以下の表に記載するように、便利で適切な HTTP 状況コードを使用してください。 

| HTTP エラー・コード | 使用指針 |
|-----------------|----------------|
| `200 (OK)` | すべてが正常で、返すデータがある場合に使用します |
| `204 (NO CONTENT)` | すべてが正常で、応答データがない場合に使用します |
| `201 (CREATED)` | 応答本文があるかないかにかかわらず、リソースが作成された POST 要求に対して使用します |
| `409 (CONFLICT)` | 同時変更で競合が発生した場合に使用します |
| `400 (BAD REQUEST)` | パラメーターの形式が正しくない場合に使用します |

詳しくは、[Response status codes ](https://tools.ietf.org/html/rfc7231#section-6){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") を参照してください。 

効率的な情報伝達のために、応答でどのようなデータを返すかについても検討する必要があります。 例えば、POST 要求でリソースが作成された場合は、新規作成されたリソースの場所を応答のロケーション・ヘッダーに含める必要があります。 作成されたリソースをフェッチするためにまた GET 要求を実行しなくても済むように、作成されたリソースも応答本文に含めることがよくあります。 同じことが、PUT および PATCH 要求にも当てはまります。

### RESTful リソース URI
{: #rest-uris}

RESTful リソース URI には、さまざまに意見が分かれる側面があります。 リソースが動詞ではなく名詞であるべきで、エンドポイントは複数なければならないという点に関しては、一般的に意見が一致しています。 そのため、CRUD 操作の構造は明確になっています。

* `POST /accounts`: 新規アカウントを作成します。
* `GET /accounts`: アカウントのリストを取得します。
* `GET /accounts/16`: 特定のアカウントを取得します。
* `PUT /accounts/16`: 特定のアカウントを更新します。
* `PATCH /accounts/16`: 特定のアカウントを更新します。
* `DELETE /accounts/16`: 特定のアカウントを削除します。

階層型 URI を使用して関係性をモデル化します。例えば、` /accounts/16/credentials` で、特定のアカウントに関連付けられた資格情報を管理します。

このような一般的な構造に当てはまらないリソースに関連する操作をどのように処理すべきかについては、あまり意見が一致していません。 このような操作を管理する 1 つの正しい方法というものは存在しないので、API 利用者にとって最適な手段を用いてください。

### 堅牢性と RESTful API
{: #robust-api}

[Robustness Principle](https://tools.ietf.org/html/rfc1122#page-12){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") に、ベスト・プラクティス「Be liberal in what you accept, and conservative in what you send」(受信するものに関しては寛容に、送信するものに関しては厳密に) が記載されています。 API は時間とともに進化するものであると想定し、理解できないデータにも寛容であってください。

#### API の生成
{: #robust-producer}

外部のクライアントに API を提供する場合は、要求を受け入れるときと応答を返すときに行わなければならないことが 2 つあります: 

* 不明な属性を要求の一部として受け入れます。
    > 不要な属性を指定して API がサービスから呼び出された場合は、単にその値を捨ててください。 このような状況でエラーを返すと、不要な障害が発生し、エンド・ユーザーに悪影響を与える可能性があります。
* 利用者が必要とする属性のみを返します。
    > 内部サービスの詳細は公開しないようにします。 利用者が必要とする属性のみを API の一部として公開します。

#### API の利用
{: #robust-consumer}

API の利用時:

* 必要な変数や属性に対する要求のみを検証します。
    > 渡されたからというだけで変数を検証しないでください。要求の一部として使用する変数でなければ、存在していても使用しないでください。
* 不明な属性を応答の一部として受け入れます。
    > 予期しない変数を受け取っても、例外を発行しないでください。必要な情報が応答に含まれている限り、他の情報が一緒に存在していても問題ありません。

これらのガイドラインは、特に Java などの強く型付けされた言語を使用する場合に役に立ちます。このような言語では、JSON シリアライゼーション/デシリアライゼーションが (例えば、Jackson ライブラリーや JSON-P/JSON-B を使用して) 間接的に実行されることが多いからです。 不明な属性は無視するなどの寛容な動作を指定したり、シリアライズする属性を定義またはフィルタリングしたりできる言語メカニズムを見つけてください。

### RESTful API のバージョン管理
{: #version-api}

マイクロサービスの主なメリットの 1 つは、個々のサービスを独立的に進化させられることです。 ただし、マイクロサービスが他のサービスを呼び出す場合、その独立性には大きな注意が必要になります。API に破壊的な変更をしてはいけません。

堅牢性の原則に従っていれば、破壊的な変更がすぐに必要になることはありません。 最終的に破壊的な変更が必要になった場合には、まったく別のサービスを作成して元のサービスを徐々に廃止していくことを選択できます。

既存のサービスのために API の破壊的な変更が必要になった場合は、それらの変更の管理方法を決定してください。サービスですべてのバージョンの API を操作できるようにしますか? API の各バージョンに対応するサービスのバージョンを個々に維持しますか? サービスでは最新バージョンの API のみをサポートするようにして、古い API から新しい API に変換するために他の適応層を利用しますか?

変更の管理方法を決定すると、API でどのようにバージョンを表すかという問題は解決しやすくなります。 REST リソースのバージョン指定方法としては、一般的に次の 3 つの方法があります。

* URI パスにバージョンを含める。
* HTTP Accept ヘッダーにバージョンを含め、コンテンツ・ネゴシエーションを利用する。
* カスタム要求ヘッダーを使用する。

#### URI パスにバージョンを含める
{: #version-path}

バージョンを指定する最も簡単な方法は、URI のパスにバージョンを含める方法です。 このアプローチの利点は、分かりやすいこと、アプリケーションでサービスを作成するときに簡単に行えること、Swagger などの API ブラウス・ツールや `curl` などのコマンド・ライン・ツールに対応していることです。

URI のパスにバージョンを含める場合、そのバージョンはアプリケーション全体に適用されます (例: `/api/accounts/v1` ではなく `/api/v1/accounts`)。 Hypermedia as the Engine of Application State (HATEOAS) とは、API 利用者自身が URI を作成しなくても済むように URI を提供する 1 つの手段です。 例えば、GitHub では、この理由で[ハイパーメディア URL](https://developer.github.com/v3/#hypermedia){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") が応答の中で提供されます。 さまざまなバックエンド・サービスの URI にそれぞれに異なるバージョンを含める場合、HATEOAS を実行することは、不可能であるか、難しくなります。

#### バージョンを含むように Accept ヘッダーを変更する
{: #version-accept}

Accept ヘッダーは、バージョンを定義する場所としてわかりやすい場所です。ただし、これは最もテストしにくい場所でもあります。 Accept ヘッダーは、機能を切り替えるための桟橋としてもよく使用されます。 HTTP ヘッダーを指定するには、API 呼び出しに関するより詳細な情報が必要になります。

#### カスタム要求ヘッダーを追加する
{: #version-custom}

API バージョンを指定するためのカスタム要求ヘッダーを追加することができます。 Accept ヘッダーと同様に、カスタム・ヘッダーを使用して、特定のバックエンド・インスタンスにトラフィックを転送することもできます。 この方法には、Accept ヘッダーと同じ使いやすさに関する問題があります。それに加え、利用者がこのヘッダーについて理解する必要もあります。

詳しくは、[Your API versioning is wrong, which is why I decided to do it 3 different wrong ways](https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") を参照してください。

## API の作成と生成
{: #create-api}

[OpenAPI v3](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") は、RESTful サービスの公式仕様で、[OpenAPI Initiative](https://www.openapis.org/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") (Linux Foundation の企業団体) によって管理されています。

以下のいずれかの方法を使用して、API を作成できます。

  * OpenAPI 定義から開始する (トップダウン): このアプローチでは、言語に依存しない形式 (通常は YAML) で OpenAPI 定義を作成することから開始します。 その後、コード生成プログラムを使用してスケルトンを作成し、そこからサービス実装環境を構築します。 このパターンは、通常、中心となる API 設計チームが存在する企業によって採用されます。また、並行して開発とテストを進めることができます。
  * コードから開始する (ボトムアップ): コードが、API 定義のソースになります。 このアプローチが効果的であるのは、実験的な側面を持つ新規アプリケーションを作成する場合です。サービスで実行すべき処理への理解が深まるにつれて API 定義が進化するからです。 また、コードから OpenAPI 定義を生成するツールを利用するので、このアプローチは一部の言語では他の言語よりも効果的に機能します。 例えば、Java には、注釈ベースの REST フレームワークから OpenAPI ドキュメントを生成できる優れたサポート機能があります。

いずれの場合も、OpenAPI 定義を使用するので、API が矛盾している領域や利用者の視点から理解しにくい領域が見つけやすくなります。 利用者に影響を与える破壊的な変更について注意喚起するために、公開またはバージョン管理されている OpenAPI 定義をビルド・ツールで使用することもできます。

### OpenAPI 定義からの API の作成
{: #openapi-first}

OpenAPI YAML ファイルは任意のツールで作成できます。 ただし、プレーン・テキスト・エディターを使用すると、間違いやすくなります。 一部のエディターには、YAML の基本的なサポートが用意されています。また、追加の拡張機能を使用して OpenAPI 定義をサポートできるエディターもあります。 例えば、[Swagger Viewer](https://marketplace.visualstudio.com/items?itemName=Arjun.swagger-viewer){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") や [OpenAPI Preview](https://marketplace.visualstudio.com/items?itemName=zoellner.openapi-preview){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") などの Visual Studio Code 拡張機能を使用して、指定した仕様バージョンに対して OpenAPI 定義を検証したり、プレビュー・ペインで Web ビューを表示したりできます。

![OpenAPI のプレビュー](images/create-api-image1.png "OpenAPI のプレビュー"){: caption="図 1. OpenAPI のプレビュー" caption-side="bottom"} 

また、オンラインやローカルで使用できるブラウザー・ベースのライブ解析エディターもたくさんあります。 以下に例を示します。

* [OpenAPI-GUI プロジェクト](https://github.com/Mermade/openapi-gui){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") は、OpenAPI 仕様の v2 と v3 の両方のバージョンをサポートしており、OpenAPI v2 定義を v3 に自動で移行することもできます。
* [SmartBear 社の Swagger Editor](https://editor.swagger.io){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") も OpenAPI の v2 と v3 の両方をサポートしています。
* [{{site.data.keyword.apiconnect_short}}](https://cloud.ibm.com/catalog/services/api-connect){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") には、API のモデル化や作成に使用できる一連のエディターやツールが用意されています。

### API 実装環境の生成
{: #code-first}

オープン・ソースの [OpenAPI 生成プログラム](https://github.com/OpenAPITools/openapi-generator){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") を使用して、OpenAPI 定義からサービス実装用のスケルトン・プロジェクトを作成できます。 コマンド・ラインからスケルトンの言語またはフレームワークを指定できます。 例えば、汎用的な JAX-RS メソッド注釈を使用するサンプル PetStore API の Java プロジェクトを作成するには、以下のコマンドを指定します:

```bash
openapi-generator generate -g jaxrs-cxf-cdi -i ./petstore.yaml -o petstore --api-package=com.ibm.petstore
```
{: pre}

