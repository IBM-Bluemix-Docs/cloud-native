---

copyright:
  years: 2019
lastupdated: "2019-02-10"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# ロギング
{: #logging}

ログ・メッセージとは、そのログ・エントリーが作成されたときのマイクロサービスの状態やアクティビティーについての状況情報が含まれた文字列です。ログは、サービスが失敗した状況や理由を診断するために必要です。アプリケーションの正常性をモニターするためのメトリックにとって、ログは補助的な役割を果たします。
{:shortdesc}

必ず、ログ・エントリーは標準出力と標準エラーのストリームに直接書き出してください。そうすることで、コマンド・ライン・ツールを使用してログ・エントリーを表示できるようになります。また、 Logstash、 Filebeat、 Fluentd などのログ転送サービスをインフラストラクチャー・レベルで構成してログの収集やデータ管理を行えるようになります。

ログを標準出力や標準エラーに書き出すようにコンテナー化アプリケーションを構成できない場合、ログ・ファイルの処理は、さらに入念な検討が必要なものになります。

* ログ・データにボリュームを使用するという方法が 1 つあります。ローカルでの開発やテストのために単純なバインド・マウントを使用するか、または Kubernetes のデプロイメントの一部として適切な永続ボリュームを使用します。[専用のサイドカーまたはロギング・エージェント](https://kubernetes.io/docs/concepts/cluster-administration/logging/#sidecar-container-with-a-logging-agent){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") で、共有ボリュームから読み取り、中央の集約機能にログを転送できます。ログ・ローテーションを明示的に構成して、ボリュームに保管されるログ・データの量を制御する必要があります。
* アプリケーション・ライブラリーまたはエージェントを使用して、直接、ログを集約機能に転送するという方法もあります。この方法では、デプロイメント環境の構成が全体的に複雑になることがあります。

## JSON ロギング
{: #json-logging}

アプリケーションが時間とともに進化するにつれて、ログに記録する内容の性質も変化することがあります。JSON ログ形式を使用すると、以下の利点があります。

* ログに索引を作成できます。作成すると、集約されたログ本文の検索が簡単になります。
* 文字列内の要素の位置に依存せずに解析できるので、ログを変更しやすくなります。

JSON 形式のログは、マシンにとっては解析しやすくても、人間にとっては読みにくいものです。環境変数を使用してログ形式を切り替え、ローカルでの開発やデバッグにはプレーン・テキストを使用し、長期保管や集約には JSON 形式のログを使用することを検討してください。

JSON 照会ツール (jq) のようなコマンド・ライン JSON パーサーを使用して、JSON 形式のログを人間が判読できる形式で表示できます。以下の例では、ログを grep にパイプ出力して、メッセージ・フィールドを含むログに絞った後に、jq で行の構文解析を実行しています。

```bash
kubectl logs trader-54b4d579f7-4zvzk -n stock-trader -c trader | \
  grep message | \
  jq .message -r
```
{: pre}

## `kubectl` を使用してログを表示する
{: #view-logs-kube}

標準出力と標準エラーのストリームに送信されたログは、Kubernetes でコンソールまたは `kubectl` コマンド (形式: `kubectl logs <podname>`) を使用して表示できます。

stock-trader などのカスタム名前空間を使用する場合は、例えば `kubectl logs -n stock-trader<podname>` のようにその名前空間をコマンドに指定します。

Istio サイドカーを使用する場合のように、ポッドごとに複数のコンテナーがある場合は、コンテナーも指定する必要があります。以下の例では、stock-trader 名前空間を使用して、`portfolio-54b4d579f7-4zvzk` ポッド内の `portfolio` コンテナーのログを表示します。

```bash
kubectl logs -n stock-trader portfolio-54b4d579f7-4zvzk -c portfolio
```
{: pre}

JSON 形式のログの場合、以下の例のように、`jq` を使用してメッセージ・フィールドを抽出できます。

```bash
kubectl logs trader-54b4d579f7-4zvzk -n stock-trader -c trader | grep message | jq .message -r
```
{: pre}

ログ・エントリーを `grep` にパイプ出力することで、メッセージ・フィールドを含む行だけを `jq` で構文解析します。
{: note}
