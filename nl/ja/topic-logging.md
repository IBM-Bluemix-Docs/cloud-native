---

copyright:
  years: 2019
lastupdated: "2019-02-10"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# ロギング
{: #logging}

ログ・メッセージは、ログ・エントリーが作成された時点の、マイクロサービスの状態およびアクティビティーに関するコンテキスト情報を含むストリングです。ログは、サービスがどのように、なぜ失敗したのかを診断するために必要です。アプリケーション正常性のモニタリングにおいて、メトリックの補助的な役割を果たします。
{:shortdesc}

ログ・エントリーを標準出力ストリームと標準エラー・ストリームに直接書き込むようにしてください。これにより、コマンド・ライン・ツールを使用してログ・エントリーを表示できるようになり、インフラストラクチャー・レベルで構成するログ転送サービス (Logstash、Filebeat、Fluentd など) によるログの収集およびデータの管理が可能になります。

標準出力または標準エラーにログを書き込むようにコンテナー化アプリケーションを構成できない場合は、ログ・ファイルを処理するために追加の対処が必要になります。

* 選択肢の 1 つは、ログ・データ用のボリュームを使用することです。ローカルでの開発およびテスト用の単純なバインド・マウントか、または Kubernetes デプロイメントの一部である適切な永続ボリュームを使用できます。[専用のサイドカーまたはロギング・エージェント](https://kubernetes.io/docs/concepts/cluster-administration/logging/#sidecar-container-with-a-logging-agent){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") は、共有ボリュームからログを読み取って、集中アグリゲーターに転送することができます。ボリュームに保管されるログ・データの量を制御するために、ログ・ローテーションを明示的に構成する必要があります。
* 別の選択肢は、アプリケーション・ライブラリーまたはエージェントを使用して、ログをアグリゲーターに直接転送することです。この方式では、各デプロイメント環境で構成が複雑になる可能性があります。

## JSON ロギング
{: #json-logging}

アプリケーションが改良されるにつれて、ログに記録する内容の特性も変化する可能性があります。JSON のログ形式を使用すると、次の利点があります。

* ログの索引付けが可能です。これにより、蓄積されたログの集まりを簡単に検索できるようになります。
* 文字列内の要素の位置に依存せずに構文を解析できるので、変化に対して弾力性のあるログになります。

JSON 形式のログは、マシンで解析するのは容易ですが、人間が読むのは困難です。環境変数を使用して、用途に合わせてログの形式を切り替えることを検討してください。ローカル環境で開発やデバッグを行う場合はプレーン・テキストを使用し、長期の保管や集約を行う場合は JSON 形式のログを使用できます。

JSON Query ツール (jq) などのコマンド・ライン JSON パーサーを使用すれば、JSON 形式ログの判読可能なビューを作成できます。次の例では、jq が行を解析する前に、メッセージ・フィールドが必ず存在するように、grep を使用してログをパイプ接続します。

```bash
kubectl logs trader-54b4d579f7-4zvzk -n stock-trader -c trader | \
  grep message | \
  jq .message -r
```
{: pre}

## `kubectl` を使用したログの表示
{: #view-logs-kube}

標準出力ストリームと標準エラー・ストリームに送信されたログは、コンソールまたは `kubectl` コマンド (その形式は `kubectl logs <podname>`) によって Kubernetes で表示できます。

カスタム名前空間 (stock-trader など) を使用する場合は、それをコマンドに含めます。例えば、`kubectl logs -n stock-trader <podname>` とします。

istio サイドカーを使用する場合のように、ポッドごとに複数のコンテナーがある場合は、コンテナーも指定する必要があります。以下の例では、`portfolio-54b4d579f7-4zvzk` ポッドの `portfolio` コンテナーからのログを表示するために、stock-trader 名前空間が使用されます。

```bash
kubectl logs -n stock-trader portfolio-54b4d579f7-4zvzk -c portfolio
```
{: pre}

JSON 形式のログの場合、`jq` を使用してメッセージ・フィールドを抽出できます。以下に例を示します。

```bash
kubectl logs trader-54b4d579f7-4zvzk -n stock-trader -c trader | grep message | jq .message -r
```
{: pre}

メッセージ・フィールドを含む行のみを `jq` が解析するように、`grep` を使用してログ・エントリーをパイプ接続しています。
{: note}
