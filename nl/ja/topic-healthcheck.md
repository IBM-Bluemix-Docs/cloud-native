---

copyright:
  years: 2019
lastupdated: "2019-02-10"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# ヘルス・チェック
{: #healthcheck}

ヘルス・チェックは、自動化されたシステム内で個々のインスタンスの正常性状況を調べるための単純なメカニズムです。そして、システムはそのような正常性検査イベントに対する応答として、検査に失格したインスタンスを置換したり、ルーティング・テーブルを更新したり、検査結果の正常性の状態をユーザーに通信したりするなどのアクションを実行します。
{:shortdesc}

Kubernetes では、コンテナーの正常性を検査するために、以下の 2 つの重要なメカニズムを定義します。

* Readiness プローブ。プロセスが要求を処理可能 (ルーティング可能) かどうかを示すために使用します。Readiness プローブに失格したコンテナーには、Kubernetes は処理をルーティングしません。Readiness プローブに失格する状況には、サービスの初期化が完了していない場合、サービスがビジーまたは過負荷の状態にある場合、あるいは要求を処理できない場合があります。
* liveness プローブ。プロセスを再起動する必要があるかどうかを示すために使用します。liveness プローブにコンテナーが失格すると、Kubernetes は、機能不良状態のポッドを終了して置換するために、そのコンテナーを停止して再起動します。liveness プローブに失格する状況には、メモリー不足状態などが発生してサービスがリカバリー不能な状態になっている場合があります。常に OK 応答を戻す単純な liveness 検査でも、要求を処理するプロセスが異常終了したのにコンテナーが実行し続けているような不整合状態にあるコンテナーを検出できます。

Readiness プローブと liveness プローブは両方とも同じような構造を使用して定義されます。この構造には、遅延時間と再試行間隔、障害許容期間、タイムアウトに加えて、プローブの実装の定義が含まれます。プローブの実装としては、コマンドを実行するか、TCP エンドポイントへの接続を検査するか、HTTP 呼び出しを実行します。プローブの実装は、Readiness と liveness の両方の目的に同じものを使用できる場合が多いですが、遅延時間と再試行間隔はそれぞれの目的に合わせて調整する必要があります。

## プローブについて理解して適用する
{: #kubernetes-probes}

基本的に、クラウド・ネイティブ・アプリケーションの開発は、コンテナー・プロセスに実際に障害が起きた場合には即時に新しいコンテナーに置き換えるという原則の上に成立しています。これは、コンテナー障害やマシン障害などの予期しないイベントへの応答としてだけでなく、水平スケーリングや新しいアプリケーション・イメージのロールアウトのような操作イベントの結果としても実行されます。Readiness 検査は、トラフィックをルーティングする前に新しいコンテナー・インスタンスが処理を受け取る準備ができているかどうかを確認するので重要です。また、同じ検査によって、終了したインスタンスや破棄処理中のインスタンスにトラフィックがルーティングされることを防止できます。

Readiness 検査を定義しないと、Kubernetes はコンテナー・インスタンスがトラフィックを処理できる状態にあるかどうかをほとんど認識できません。そのため、コンテナー・プロセスの起動直後にトラフィックをルーティングします。Readiness 検査を行わないと、要求を処理できる状態にないインスタンスに処理がルーティングされ、アプリケーションが接続タイムアウトになったり接続拒否応答を受け取ったりする可能性が高くなります。Readiness 検査によって、クライアント接続エラーを減らせますが、完全になくすことはできません。

コンテナー対応アプリケーションのライフサイクルの中で、インスタンスのルーティング・ターゲットが変更されるのは正常な動作ですが、liveness 検査で検出するプロセス状態は、発生頻度の少ない状態であり、正常な状態ではなく例外的な状態を表します。リカバリー不能な状態になったプロセスは、実質的に作動不能です。このような状態になる理由には、メモリー不足の状況や、プログラミング・エラーによるデッドロックなどがあります。このような状態からリカバリーする最善の方法は、コンテナーを終了することです。コンテナーを終了すれば、結果的にそのコンテナー内で実行されていた処理も終了します。この方法では、コンテナーが完全にオンラインになる前にコンテナーの終了と置換が行われるというアプリケーションの終了ループまたは再起動ループが発生する可能性もあります。

Readiness プローブと liveness プローブがシステムに影響を与える方法は異なります。これについては状態遷移という観点で考えることができます。Readiness 検査の陽性状態はルーティング可能であり、陰性状態はルーティング不能です。同様に、liveness 検査の陽性状態はコンテナーが正常に稼働していることを意味し、陰性状態は作動不能であることを意味します。コンテナーを起動すると、Readiness 状態は最初は陰性状態ですが、そのコンテナーが正常な状態になって初めて陽性状態になります。liveness 検査は最初は陽性状態ですが、プロセスが作動不能になった場合のみ陰性状態になります。

厳しい Readiness 検査を構成しても (初期遅延値を低く設定するなど) 効果はほとんどありません。プローブを早く実行しても、Readiness 検査の状態は変わらないからです。一方、厳しい liveness 検査を構成すると、プローブがすぐに実行されて状態遷移が変わるので、システムがコンテナーを想定より早く終了できることになります。

## プローブを構成するためのベスト・プラクティス
{: #probe-recommendation}

HTTP を使用して正常性プローブを実装する場合は、以下の HTTP 状況コードで Readiness、liveness、正常性を判断することを検討してください。

| 状態     |  Readiness              |  liveness                  |
|----------|-----------------------|-----------------------|
|          | OK でなければ処理を与えない        | OK でなければ再起動する      |
| 起動中   | 503 - 使用不可        | 200 - OK              |
| 稼働中   | 200 - OK              | 200 - OK              |
| 停止中   | 503 - 使用不可        | 200 - OK              |
| ダウン   | 503 - 使用不可        | 503 - 使用不可        |
| エラー   | 500 - サーバー・エラー| 500 - サーバー・エラー|
{: caption="表 1. HTTP 状況コード" caption-side="bottom"}

許可や認証が必要なものをヘルス・チェックのエンドポイントにしてはいけません。こうした保護は正常性プローブのエンドポイントには適用されないので、HTTP プローブ実装は、データを変更しない GET 要求だけにしてください。オペレーティング・システム、実装言語、ソフトウェア・バージョンなどの環境の詳細を示すデータは決して戻さないでください。このようなデータは攻撃ベクトルの確立に使用される可能性があります。

liveness プローブの検査内容は非常に慎重に検討する必要があります。失格するとプロセスが即時に終了されるからです。プロセスの異常を時折しか示さないようなあいまいなメトリックは使用しないでください。例えば、常に `{"status": "UP"}` と状況コード 200 を戻す単純な HTTP エンドポイントを使用してください。作動不能状態のプロセスのほとんどはこの検査に失格するので、正しく再起動がトリガーされます。

ヘルス・チェックは頻繁に実行されるので、追加のオーバーヘッドが発生することがあります。Readiness プローブと liveness プローブでデータベースやマイクロサービスなどのバッキング・サービスの生存確認を行うのは、許容できるフォールバックが存在しない場合に限ってください。liveness プローブについては、バッキング検査を組み込むのは、結果が不合格になるとローカル・コンテナーがリカバリー不能状態になる場合に限ってください。Readiness プローブについては、バッキング・サービスを検証するのは、検証に失格するとローカル・コンテナーが要求を処理できない状態 (ただし、リカバリー可能な状態) になる場合に限ってください。

初期遅延時間を構成する際には、Readiness プローブでは想定される最小の値を使用し、liveness 検査では想定される最大の時間値を使用する必要があります。例えば、アプリケーション・サーバーの起動に 30 秒かかる傾向がある場合は、一般には Readiness 遅延を 10 秒にします。liveness 検査では、終了可能状態を検査する前にサーバーの起動が確実に完了するように、60 秒の値を使用します。

プローブの実装が比較的軽量であれば、通常、ルーティングを判断する *periodSeconds* 属性には 1 桁の値を構成します。例えば、サーバー・サイドでほとんど処理を行わずに 200 OK 状況を戻す HTTP プローブは、プロセッサーへの負荷が最小限で済むので、すぐに 1 - 5 秒間隔で実行できます。

## Kubernetes でのプローブの構成
{: #probe-config}

liveness プローブと Readiness プローブは、コンテナー・エレメント内で Kubernetes デプロイメントと一緒に宣言します。両方のプローブに以下の同じ構成パラメーターを使用します。

| パラメーター | 説明 |
|-----------|-------------|
| *initialDelaySeconds* | コンテナーの作成後に最初のプローブを行う前に Kubelet が待機する時間。 |
| *periodSeconds* | Kubelet がサービスのプローブを実行する頻度。デフォルトは、1 です。 |
| *timeoutSeconds* | プローブがタイムアウトする時間。デフォルト値と最小値は 1 です。 |
| *successThreshold* | 失格した後、プローブに合格する必要がある回数。デフォルト値と最小値は 1 です。liveness プローブの場合、この値は 1 でなければなりません。 |
| *failureThreshold* | ポッドの起動時にプローブに失格した場合に、Kubernetes がポッドの再起動を試行する回数。これを超えると中断します (注を参照)。最小値は 1 で、デフォルト値は	3 です。 |

  liveness プローブの場合、中断とはポッドを再起動することを意味します。Readiness プローブの場合、中断とはポッドを処理不能状態としてマーキングすることを意味します。
  {: note}

再起動の繰り返しを防ぐために、`livenessProbe.initialDelaySeconds` パラメーターには、サービスの初期化にかかる時間よりも十分に長い時間を設定してください。そして、処理可能な状態になったらすぐに要求をサービスにルーティングするために、`readinessProbe.initialDelaySeconds` 属性には小さい値を使用してください。

以下に構成の例を示します (パスとポートの値に注意してください)。

```yaml
spec:
  containers:
  - name: ...
    image: ...
    readinessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 60
      timeoutSeconds: 5
    livenessProbe:
      httpGet:
        path: /liveness
        port: 8080
      initialDelaySeconds: 130
      timeoutSeconds: 10
      failureThreshold: 10
```
{: codeblock}

詳細については、Kubernetes の [Configure Liveness and Readiness Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") を参照してください。
