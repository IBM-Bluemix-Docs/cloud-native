---

copyright:
  years: 2019
lastupdated: "2019-05-20"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# クラウド・ネイティブとは?
{: #overview}

クラウド・コンピューティング環境は、仮想化された共有プールのリソースの割り振りと解放がオンデマンドで行われる動的な環境です。 こうした弾力的な環境では、従来のオンプレミス・データ・センターで一般的に使用される事前リソース割り振りに比べて、より柔軟なスケーリング方法が可能になります。
{:shortdesc}

[Cloud Native Computing Foundation](https://github.com/cncf/foundation/blob/master/charter.md){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") によると、クラウド・ネイティブ・システムには以下の性質があります。

- アプリケーションまたはプロセスは、独立した単位であるソフトウェア・コンテナーの内部で実行される。
- プロセスを中央のオーケストレーション・プロセスで管理することで、リソース使用率の向上および保守コストの削減を図る。
- アプリケーションまたはサービス (マイクロサービス) は、明示的に指定した依存関係と疎結合される。

これらの性質は、複数の独立したプロセスが連携してビジネス価値を提供する極めて動的なシステム、つまり、分散システムを表しています。

分散コンピューティングは、数十年前に端を発する概念です。 [Fallacies of Distributed Computing](https://www.simpleorientedarchitecture.com/8-fallacies-of-distributed-systems/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") には、分散システムのアーキテクトや設計者が想定してしまう (最終的には誤りであったことがわかる) 前提が記載されています。 

* ネットワークは信頼できる。
* ネットワークはセキュアである。
* ネットワークは均質である。
* 待ち時間はゼロである。
* 帯域幅は無限である。
* トポロジーは変化しない。
* 管理者は 1 人である。
* 転送コストはゼロである。

Kubernetes や Istio などのクラウド・テクノロジーは、これらの問題にインフラストラクチャー自体で対処することを目的としています。

## 12 の要素
{: #twelve-factors}

[Twelve-Factor Application](https://12factor.net){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") 方法論は、Heroku の開発者が提唱したものです。 この 12 の要素で表されている特性は、クラウドのプロバイダー、プラットフォーム、言語に限定される内容ではありません。 これらの要素は、クラウド環境で成功する、ポータブルで耐障害性のあるアプリケーション (具体的には Software as a Service アプリケーション) を作成するための一連のガイドラインやベスト・プラクティスを表しています。 12 の要素を以下にリストします。

1. バージョン管理されているコードベース (git リポジトリーなど) とデプロイされたサービスは 1 対 1 の関係である。 同じコードベースをさまざまなデプロイメントに使用する。
2. サービスはすべての依存関係を明示的に宣言し、システム・レベルのツールやライブラリーの存在に依存しない。
3. デプロイメント環境によって異なる構成は、その環境 (具体的には環境変数) に保管する。
4. すべてのバッキング・サービスを、アタッチされたリソースとして扱い、実行環境で管理 (アタッチとデタッチ) する。
5. デリバリー・パイプラインの「ビルド」、「リリース」、「実行」のステージを厳密に分ける。
6. アプリケーションを 1 つ以上のステートレスなプロセスとしてデプロイする。 具体的には、一時プロセスはステートレスであり、シェアード・ナッシングである。 永続データは適切なバッキング・サービスに保管する。
7. 自己完結型サービスは、指定されたポートで listen することで他のサービスに自サービスを公開する。
8. 並行性を高めるには、個々のプロセスをスケーリング (水平スケーリング) する。
9. プロセスは破棄可能である。高速起動と正常シャットダウンの動作が、より堅固で耐障害性の高いシステムにつながる。
10. ローカルの開発環境から実動環境まで、すべての環境をできる限り同じ環境にする。
11. アプリケーションではログをイベント・ストリームとして (`stdout` や `stderr` に書き込むなどして) 生成し、ストリームの集約は実行環境に任せる。
12. 1 回限りの管理タスクが必要な場合は、管理タスクをソース制御に保持し、アプリケーションと同じ環境で実行するためにアプリケーションと一緒にパッケージする。

これらの要素に厳密に従わなくても高品質なマイクロサービス環境は実現できます。しかし、これらの要素を念頭に置いていれば、継続的デリバリー環境でポータブルなアプリケーションやサービスを構築、保守することが可能になります。

## マイクロサービス
{: #microservices}

*マイクロサービス* とは、独立した小さいアーキテクチャー・コンポーネントの集合です。コンポーネントごとに 1 つの目的を持ち、単純な共通 API を介して通信します。 次の単純な例に示している各マイクロサービスは 12 要素アプリケーションであり、置換可能なバッキング・サービスを使用してデータを保管し、メッセージを渡します:

![マイクロサービス・アプリケーション](images/microservice.png "マイクロサービス・アプリケーション")

マイクロサービスは独立しています。 俊敏性はマイクロサービス・アーキテクチャーの利点の 1 つですが、俊敏性を得るには、他のサービスを中断させずにサービスを完全に再作成できなければなりません。 このような状況がよく起きるというわけではなく、要件を表しています。 明確な API 境界があれば、サービスの開発に取り組むチームは、最大限に柔軟に実装を進化させることができます。 このような特性が、多言語プログラミングと永続性を可能にします。

マイクロサービスは耐障害性を持ちます。 アプリケーションの安定性は、個々のマイクロサービスの耐障害性に依存します。 これは、従来のアーキテクチャー (基礎のインフラストラクチャーが自動的に障害に対処する) とは大きな違いです。 各サービスが、回路ブレーカーやバルクヘッドなどの分離パターンを適用して障害を封じ込め、適切なフォールバック動作を定義してアップストリーム・サービスを保護する必要があります。

マイクロサービスはステートレスな一時プロセスです。 これは、マイクロサービスが状態を保持できないという意味ではありません。 状態の保管先を、メモリー内ではなく、Redis などの外部バッキング・クラウド・サービスにする必要があることを意味します。 さらに、負荷に対応したりシステムの正常性を維持したりするためにインスタンスが作成/破棄される自動化環境では、高速起動と正常シャットダウンの動作によって、マイクロサービスの適切な実行が可能になります。

### 「小さい」の意味
{: #small-microsvc}

マイクロサービスに「小さい」という言葉が使用されるのは、基本的には、用途に焦点が当てられているからです。つまり、マイクロサービスは 1 つの処理を実行すべきであり、その 1 つの処理を適切に実行すべきであるということです。 個々のマイクロサービスの役割を、Unix コマンド・ラインで次のようにコマンドをつなげることに例える説明がよく行われます。

```
ls | grep 'service' | sort -r
```
{:pre}

これらの Unix コマンドはそれぞれまったく別のタスクを実行するので、プログラミング言語やコードの量にかかわらず一緒につなげて使用できます。

## 多言語アプリケーション: ジョブに合った適切なツールを選択する
{: #polyglot-apps}

多言語は、マイクロサービス・ベースのアーキテクチャーの利点としてよく挙げられる利点です。 サービスで提供する機能に合った適切な言語やデータ・ストアを選択できることは非常に強力であり効率的です。 しかし一方で、不明瞭なテクノロジーを使用することは、長期保守を複雑にし、チーム間の開発者の移動を妨げる可能性があります。 

この 2 つのバランスを取るために、選択できるサポート対象テクノロジーのリストを最初に作成してください。そのときに、今後新しいテクノロジーをリストに追加するためのポリシーも定義しておきます。 俊敏性を保持し、実験による革新をサポートしながら、保守性、監査性、データ・セキュリティーなどの非機能的要件や規制要件を満たせるようにしてください。

## REST と JSON
{: #rest-json}

多言語アプリケーションは、言語に依存しないプロトコルでのみ可能です。 REST アーキテクチャー・パターンは、サービスの実装から転送データの表記を分離する統一インターフェースを作成するためのガイドラインを定義したものです。

JSON は、比較的単純で簡潔であることから、マイクロサービス・アーキテクチャーでテキスト・ベースのデータの最適な転送形式として台頭し、XML に取って代わっています。 比較するために、1 人の従業員に関するデータが入った JSON 形式の基本的なレコードの例を次に示します。

```json
{
  "name": "Marley Cassin",
  "serial": 228264,
  "title": "Senior Software Engineer",
  "address": {
    "office": "501-B101",
    "street": "3858 Kuvalis Pass",
    "city": "East Craig",
    "state": "NC",
    "zip": "64519-8934"
  }
}
```
{: codeblock}

次の例は、同じ従業員の XML 形式のレコードです:

```xml
<person>
  <name>Marley Cassin</name>
  <serial>228264</serial>
  <title>Senior Software Engineer</title>
  <address>
    <office>501-B101</office>
    <street>3858 Kuvalis Pass</street>
    <city>East Craig</city>
    <state>NC</state>
    <zip>64519-8934</zip>
  </address>
</person>
```
{: codeblock}

JSON では、属性と値のペアを使用して、簡潔な構文でデータ・オブジェクトを表せます。この構文では、数値、文字列、配列、オブジェクトなどのいくつかの基本タイプに関する情報が保持されます。 上記の例では、ネストされた address オブジェクトは JSON でも XML でも明確に表されていますが、`serial` 要素のタイプを判別するためには関連する XML スキーマが必要です。 JSON では、`serial` の値が数値であって文字列ではないことが構文から明確です。
