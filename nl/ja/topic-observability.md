---

copyright:
  years: 2019
lastupdated: "2019-04-09"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 可観測性、テレメトリー、モニタリング
{: #observability-cn}

クラウド・ネイティブへの移行に伴い、モニタリングの方針が変化しています。オンプレミス環境でもクラウド・ネイティブ環境でもアプリケーションには高い可用性と耐障害性が求められますが、こうした目標を達成するために採用する方式は両環境間で大きく異なります。そのため、モニタリングの目的が変化しました。障害を回避するためのモニタリングから、障害を管理するためのモニタリングへの変化です。
{:shortdesc}

オンプレミス環境では、インフラストラクチャーとミドルウェアは、計画された容量および高可用性のパターン (Active-Active や Active-Passive など) に基づいてプロビジョンされます。この環境では、予期しない障害が複雑で、問題判別と復旧に多大の労力が必要になる場合があります。外部モニタリングは、既知の種類の障害を回避するためにリソース使用状況を調べる、エージェントによって実行されます。例えば、Java アプリケーションのヒープ・サイズ、タイムアウト、およびガーベッジ・コレクション・ポリシーの調整と考えてください。

クラウド・ネイティブ・アプリケーションは、独立したマイクロサービスと必要なバッキング・サービスで構成されます。クラウド・ネイティブ・アプリケーションは全体として常に使用可能で機能し続けなければなりませんが、個々のサービス・インスタンスは、容量の要件に応じた調整や障害からの復旧のために、必要に応じて始動または停止します。 

## 可観測性
{: #observability}

こうした柔軟なシステムをモニターするには、関係する各エンティティーが*可観測性*を備えている必要があります。各エンティティーは、問題検出とアラートの自動化、必要時の手動デバッグ、システム・ヘルスの分析 (履歴トレンドおよびアナリティクス) をサポートするための適切なデータを生成する必要があります。

可観測性を備えたサービスは、以下に示す種類のデータを生成する必要があります。

* **ヘルス・チェック** (多くの場合、カスタム HTTP エンドポイント) は、システム全体の正常性を維持するために、自動化されたアクションをオーケストレーター (Kubernetes や Cloud Foundry など) が実行するのに役立ちます。
* **メトリック**は、一定間隔で時系列に収集されたデータの数値表現です。時系列の数値データは保管と照会が容易であり、履歴トレンドを調べる際に役立ちます。経過した期間の長さに応じて、数値データをより細分度の低い集約 (例えば、日次や週次) に圧縮できます。
* **ログ・エントリー**は、時間の経過とともに発生した個々のイベントを表します。ログ・エントリーはデバッグに不可欠です。ログ・エントリーには多くの場合、検知された障害の根本原因を特定するのに役立つ、スタック・トレースなどのコンテキスト情報が含まれるためです。
* **分散、要求、またはエンドツーエンドのトレース**では、システム全体にわたる、要求のエンドツーエンド・フローをキャプチャーします。トレースでは基本的に、サービス (要求に関わったサービス) 間の関係と、システム内を流れる処理の構造 (同期処理または非同期処理、子または派生の関係) の両方をキャプチャーします。

## テレメトリー
{: #telemetry}

クラウド・ネイティブ・アプリケーションは、*テレメトリー* 対応の環境に依存する必要があります。テレメトリーとは、データを自動的に収集して集中管理ロケーションに送信して、その後分析できるようにすることです。この点は、ログをイベント・ストリームとして扱うという、12 要素 (twelve factors) の 1 つで強調されており、監視可能になるためにマイクロサービスが生成するすべてのデータに適用されます。

Kubernetes にはいくつかのテレメトリー機能 (Heapster など) が組み込まれていますが、Kubernetes コントロール・プレーンに統合された他のシステムによってテレメトリーが提供される場合のほうが多いでしょう。例えば、Istio の 2 つのコンポーネント (Mixer と Envoy) は、連携して透過的に、[デプロイ済みのアプリケーションからテレメトリー・データを収集](https://istio.io/docs/concepts/policies-and-telemetry/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") します。

障害は、たまに発生する致命的な事象、という性質のものでなくなりました。モノリシック・アプリケーションを複数のマイクロサービスに分割すると、より多くのメインライン・パスによってネットワークが使用されるため、待ち時間や他のネットワークの問題による影響が大きくなります。さらに、要求を受け付けたプロセスが、さまざまな理由で、処理できない状態にある場合もあります。サービスは、リソースが枯渇すると自動的に再始動します。また、フォールト・トレランス方式によって、システム全体は機能し続けることができます。こうした環境では、個々の障害に対して手操作で介入することは、あまり役に立たないか、あるいは実行が容易ではありません。

## モニタリング
{: #monitoring}

可観測性とテレメトリーの概念は、大規模な分散システムでクラウド・ネイティブ・アプリケーションをモニターする際の大きな違いを明らかにします。クラウド・ネイティブ環境でのプロセスは一時的なものであることに留意してください。この点は、12 要素のうちの 3 つ (プロセス、並行性、廃棄容易性) によって強調されます。事前に割り振られ、長時間実行されるモノリシック・プロセスは、多くの短時間プロセスに置き換えられるか、囲まれます。それらの短時間プロセスは、プロセスが正常に機能していない場合に、または水平スケーリングのために負荷に応じて開始および停止されます。テレメトリーは、プロセス (コンテナー) が作成および破棄されるときにデータが失われないように、データを収集して別の場所に保持する必要がある場合に重要です。テレメトリーは、コンプライアンス上の理由で必要な場合もよくあります。 

上記のすべての理由により、モニタリングの対象が変化しました。リソース (個々のプロセスまたは個々のマシン) の動作と正常性をモニターするのではなく、システム全体の状態をモニターするのです。個々のサービスがそれぞれデータを生成し、それらのデータによって集約ビューが形成されます。

