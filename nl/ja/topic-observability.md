---

copyright:
  years: 2019
lastupdated: "2019-04-09"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 可観測性、テレメトリー、およびモニタリング
{: #observability-cn}

クラウド・ネイティブへのシフトに伴い、モニタリングの文化も変化しています。オンプレミス環境でもクラウド・ネイティブ環境でも、アプリケーションには高い高可用性と耐障害性が求められますが、これらの目標を達成するために使用される方法は大きく異なります。その結果、モニタリングの目的が、障害を回避するためのモニタリングから、障害に対処するためのモニタリングにシフトしています。
{:shortdesc}

オンプレミス環境では、インフラストラクチャーとミドルウェアは、計画されたキャパシティーと高可用性のパターン (アクティブ - アクティブかアクティブ - パッシブかなど) に基づいてプロビジョンされます。このような環境の予期しない障害は複雑で、問題判別と復旧にかなりの労力が必要になる場合があります。既知の分類の障害を回避するために、リソース使用状況を調べるエージェントによって、外部モニタリングを実行します。例として、Java アプリケーションのヒープ・サイズ、タイムアウト、ガーベッジ・コレクション・ポリシーの調整を考えてみてください。

クラウド・ネイティブ・アプリケーションは、独立したマイクロサービスと必要なバッキング・サービスで構成されます。クラウド・ネイティブ・アプリケーションは、全体として使用可能な状態を維持して稼働を継続しなければなりませんが、個々のサービス・インスタンスは、キャパシティー要件に合わせた調整や障害復旧のために、必要に応じて起動/停止されます。   

## 可観測性
{: #observability}

このように流動的なシステムをモニターするためには、参加要素のそれぞれが*観測可能* である必要があります。各エンティティーが、自動による問題検出とアラート生成、手動デバッグ (必要な場合)、システムの正常性の分析 (履歴の傾向と分析) をサポートするために適切なデータを生成しなければなりません。

観測可能であるためにサービスが生成しなければならないデータの種類

* **ヘルス・チェック** (多くの場合、カスタム HTTP エンドポイント): Kubernetes や Cloud Foundry などのオーケストレーターでは、ヘルス・チェックを使用して、システム全体の正常性を維持するための自動アクションを実行します。
* **メトリック**: これは、間隔を置いて時系列に収集されたデータの数値表現です。時系列の数値データは保管も照会も簡単であるため、履歴の傾向を見つけるときに役立ちます。長期的には、大きな単位 (例えば、日単位や週単位) で集約して数値データを圧縮できます。
* **ログ・エントリー**: これは、時系列で発生した個々のイベントを表します。ログ・エントリーはデバッグに必須です。スタック・トレースなど、観測された障害の根本原因を特定するのに役立つ状況情報がよく含まれているからです。
* **分散トレース、要求トレース、またはエンドツーエンド・トレース**: これらには、システム内部の要求のフローがエンドツーエンドで記録されます。トレースには、基本的に、サービス (要求に関係したサービス) 間の関係とシステム内部の処理フローの構造 (同期処理か非同期処理か、子の関係か後続の関係か) の両方が記録されます。

## テレメトリー
{: #telemetry}

*テレメトリー* については、クラウド・ネイティブ・アプリケーションは環境に依存する必要があります。テレメトリーとは、データを自動的に収集し、後で分析するために中央のロケーションに自動的にデータを伝送することです。これは 12 の要素の中の「ログをイベント・ストリームとして扱う」という要素で強調されており、観測可能なマイクロサービスであるためにマイクロサービスが生成するすべてのデータに適用されます。

Kubernetes には Heapster などの組み込みテレメトリー機能がいくつかありますが、Kubernetes コントロール・プレーンと統合された他のシステムがテレメトリーを装備していることがよくあります。例えば、Istio の 2 つのコンポーネント Mixer と Envoy は、一緒に動作して、[デプロイされたアプリケーションからのテレメトリーの収集](https://istio.io/docs/concepts/policies-and-telemetry/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") を透過的に行います。

もはや障害は、めったに起きない破壊的な状況ではありません。モノリシックなアプリケーションをマイクロサービスに分割することで、より多くのメインライン・パスがネットワークにプッシュされ、待ち時間などのネットワークの問題の影響が大きくなります。また、いくつもの理由で処理できる状態でないプロセスに要求が到達します。リソース不足であればサービスは自動的に再起動され、フォールト・トレランス戦略により、システムは全体として稼働を継続できます。このような環境では、個々の障害に手操作で介入することは、あまり有用ではなく、実行可能でないこともあります。

## モニタリング
{: #monitoring}

可観測性とテレメトリーの概念は、大規模な分散システムのクラウド・ネイティブ・アプリケーションをモニターする方法の重要な違いを強調するために役に立ちます。クラウド・ネイティブ環境内のプロセスは一時的であるということに注意してください。12 要素のうちの 3 つ (プロセス、並行性、破棄可能性) はこの点を強調しています。事前割り振りされ、長期実行されるモノリシックなプロセスは、水平スケーリングで負荷に対応したり機能異常に対処したりするために起動/停止されるはるかに多くの短命なプロセスに置き換えられたり囲まれたりしています。プロセス (コンテナー) は作成された後に破棄されるので、データを収集し、失われないようにどこか別の場所に保持する必要がある場合は、テレメトリーが重要です。コンプライアンス上の理由でも、しばしばテレメトリーが必要になります。 

前述のすべての理由で、モニタリングの焦点は変化しています。リソース (個々のプロセスまたは個々のマシン) の動作と正常性をモニターするのではなく、システムの状態を全体としてモニターするようになってきています。個々のサービスが生成したデータから、そのような集約されたビューにデータがフィードされます。

