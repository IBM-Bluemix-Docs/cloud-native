---

copyright:
  years: 2019
lastupdated: "2019-07-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 可観測性、テレメトリー、モニタリング
{: #observability-cn}

クラウド・ネイティブへの移行に伴い、モニタリングの方針が変化しています。 オンプレミス環境でもクラウド・ネイティブ環境でもアプリケーションには高い可用性と耐障害性が求められますが、こうした目標を達成するために採用する方式は両環境間で異なります。そのため、モニタリングの目的が変化しました。障害を回避するためのモニタリングから、障害を管理するためのモニタリングへの変化です。 
{:shortdesc}

オンプレミス環境では、インフラストラクチャーとミドルウェアは、計画された容量および高可用性のパターン (Active-Active や Active-Passive など) に基づいてプロビジョンされます。 この環境では、予期しない障害が複雑で、問題判別と復旧に多大の労力が必要になる場合があります。 外部モニタリングは、既知の種類の障害を回避するためにリソース使用状況を調べる、エージェントによって実行されます。 例えば、Java アプリケーションのヒープ・サイズ、タイムアウト、およびガーベッジ・コレクション・ポリシーの調整と考えてください。

クラウド・ネイティブ・アプリケーションは、独立したマイクロサービスと必要なバッキング・サービスで構成されます。 クラウド・ネイティブ・アプリケーションは全体として常に使用可能で機能し続けなければなりませんが、個々のサービス・インスタンスは、容量の要件に応じた調整や障害からの復旧のために、必要に応じて始動または停止します。 

## 可観測性
{: #observability}

こうした柔軟なシステムをモニターするには、関係する各エンティティーが*可観測性*を備えている必要があります。 各エンティティーは、問題検出とアラートの自動化、必要時の手動デバッグ、システムの正常性の分析 (履歴トレンドおよびアナリティクス) をサポートするための適切なデータを生成する必要があります。

可観測性を備えたサービスは、以下に示す種類のデータを生成する必要があります。

* **ヘルス・チェック** (多くの場合、カスタム HTTP エンドポイント) は、システム全体の正常性を維持するために、自動化されたアクションをオーケストレーター (Kubernetes や Cloud Foundry など) が実行するのに役立ちます。
* **メトリック**は、一定間隔で時系列に収集されたデータの数値表現です。 時系列の数値データは保管と照会が容易であり、履歴トレンドを調べる際に役立ちます。 経過期間が長くなった場合は、数値データをより大きな単位に (例えば、日次や週次) 集約できます。
* **ログ・エントリー**は、個々のイベントを表します。ログ・エントリーはデバッグに不可欠です。ログ・エントリーには多くの場合、検知された障害の根本原因を特定するのに役立つ、スタック・トレースなどのコンテキスト情報が含まれるためです。
* **分散、要求、またはエンドツーエンドのトレース**では、システム全体にわたる、要求のエンドツーエンド・フローをキャプチャーします。 トレースでは基本的に、サービス (要求に関係したサービス) 間の関係と、システム内の処理の構造 (同期処理または非同期処理、子または派生の関係) の両方をキャプチャーします。

## テレメトリー
{: #telemetry}

クラウド・ネイティブ・アプリケーションは、*テレメトリー* 対応の環境に依存します。テレメトリーとは、後で分析できるようにデータを自動的に収集して一元管理のロケーションに送信することです。この点は、ログをイベント・ストリームとして扱うという、12 要素 (twelve factors) の 1 つで強調されており、マイクロサービスが生成するすべてのデータに適用されています。これによって、これらのデータは確実に観測可能になります。

Kubernetes にはいくつかのテレメトリー機能 (Heapster など) が組み込まれていますが、多くの場合、テレメトリーは Kubernetes コントロール・プレーンに統合された他のシステムによって提供されます。 例えば、Istio の 2 つのコンポーネント (Mixer と Envoy) は、連携して透過的に、[デプロイ済みのアプリケーションからテレメトリー・データを収集](https://istio.io/docs/concepts/policies-and-telemetry/){: new_window} ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン") します。

障害は、たまに発生する致命的な事象、という性質のものでなくなりました。 モノリシック・アプリケーションを複数のマイクロサービスに分割すると、メインライン・パスのより多くの部分でネットワークが使用されるため、待ち時間や他のネットワークの問題による影響が大きくなります。 さらに、要求を受け付けたプロセスが、さまざまな理由で、処理できない状態にある場合もあります。 サービスは、リソースが枯渇すると自動的に再始動します。また、フォールト・トレランス方式によって、システム全体は機能し続けることができます。 こうした環境では、個々の障害に対して手操作で介入することは、役に立たないか、あるいは現実的ではありません。

## モニタリング
{: #monitoring}

可観測性とテレメトリーの概念は、大規模な分散システムでクラウド・ネイティブ・アプリケーションをモニターする際の大きな違いを明らかにします。 クラウド・ネイティブ環境でのプロセスは一時的なものであることに留意してください。 この点は、12 要素のうちの 3 つ (プロセス、並行性、廃棄容易性) によって強調されます。 事前に割り振られ、長時間実行されるモノリシック・プロセスは、多くの短時間プロセスに置き換えられるか、囲まれます。それらの短時間プロセスは、プロセスが正常に機能していない場合に、または水平スケーリングのために負荷に応じて開始および停止されます。 テレメトリーは、プロセス (コンテナー) が作成および破棄されるときにデータが失われないように、データを収集して別の場所に保持する必要がある場合に重要です。 テレメトリーは、コンプライアンス上の理由で必要な場合もよくあります。 

上記のすべての理由により、モニタリングの対象が変化しました。リソース (個々のプロセスまたは個々のマシン) の動作と正常性をモニターするのではなく、システム全体の状態をモニターするのです。 個々のサービスがそれぞれデータを生成し、それらのデータによって集約ビューが形成されます。

## トレース、ロギング、メトリックの比較
{: #trace-log-metrics}

:FIXME -- rephrase comparison as topic summary:

ロギングは、開発者が明示的にメッセージを出力して表示できるようにしたい場合に使用します。関連する変数の値を渡すなど、Java クラスに直接コーティングします。問題が発生した場合には、スローされた例外のスタック・トレースなどのように障害の発生場所がわかるので、ログはデバッグの役に立ちます。*Kibana* を使用すると、複数のポッド/マイクロサービスのこのようなログを統合して表示できます。

トレースは自動的に行われるので、開発者による操作は不要です。例えば、JAX-RS 注釈付きメソッドが呼び出されたら Open Tracing 準拠のトレース・サーバーにトレース・レコードを送信するように Liberty を構成できます。このようにして、呼び出されたもの、呼び出したもの、呼び出しに要した時間に関する監査レコードを取得できます。また、そのようなトレースを拡張することもできます。例えば、Open Tracing 注釈をトレース対象のプライベート・メソッドに追加して、コードで呼び出されたプライベート・メソッドに関する情報を含めることができます。 

*Zipkin* や *Jaeger* などのツールを使用すれば、複数のポッド/マイクロサービスのトレースを統合して表示できます。また*サービス・メッシュ*にも、コンテナーのサイドカーを介して渡される呼び出しを自動トレースする機能が備わっています。  

メトリックを使用して、集約値を追跡できます。例えば、特定のユーザーによるポートフォリオの作成頻度を調べるために大量のトレースやログを調べる代わりに、カスタムのカウンター・メトリックを作成できます。例えば、ポッドで /metrics URI に定期的にヒットして、*Prometheus* で「収集」されるようにデプロイメントにラベルを付けることができます。その後、*Grafana* などのツールを使用して、複数のポッド/マイクロサービスのメトリックを統合して表示できます。

トレースを参照すれば、「このメソッドが呼び出された」ことを確認できます。しかし、「呼び出されたときにこのメソッドの内部で起きていたこと」を調べるには、ロギングを参照します。また、「呼び出された回数」を調べたい場合はメトリックを参照します。通常、トレースは暗黙的であり、開発者側で労力をかけることなく自動的に実行されます。一方、ロギングは明示的であり、問題の事後分析に役立つ可能性がある情報を送信するように開発者がコーディングする必要があります。メトリックも、コードの該当メソッドに注釈を追加する必要がある場合には明示的です (ただし、メモリー使用量、CPU 使用量、スレッド数などのように、プログラマー側で労力をかけずに低水準のデフォルト・メトリックを使用できる場合も少なくありません)。

一般的に、メトリックは分析に役立ち、ロギングは問題判別に役立ち、トレースはマイクロサービス間の制御フローを調べるのに役立ちます。
