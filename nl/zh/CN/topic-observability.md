---

copyright:
  years: 2019
lastupdated: "2019-07-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 可观察性、遥测和监视
{: #observability-cn}

随着转变为云本机，与监视相关的文化也发生了变化。虽然内部部署和云本机环境中的应用程序都应该具备高可用性且能弹性应对故障，但用于实现这些目标的方法却各不相同。因此，监视的目的发生了转变：监视不再是为了避免故障，而是为了管理故障。
{:shortdesc}

在内部部署环境中，基础架构和中间件基于计划的容量和高可用性模式（例如，主动/主动或主动/被动）进行供应。在这种环境中，意外的故障可能很复杂，需要大量工作来确定问题并进行恢复。外部监视由检查资源利用率的代理程序来执行，以避免已知类别的故障。例如，考虑调整 Java 应用程序的堆大小、超时和垃圾回收策略。

云本机应用程序由独立的微服务和必需的后备服务组成。尽管云本机应用程序作为整体必须保持可用并继续运行，但仍可启动或停止个别服务实例，以根据容量需求进行调整或从故障中恢复。 

## 可观察性
{: #observability}

监视这一流动系统需要*可观察*每个参与者。每个实体必须生成相应的数据，以支持自动问题检测和发出警报，在必要时进行手动调试，以及分析系统运行状况（历史趋势和分析）。

要使服务可观察，服务应该生成哪些类型的数据？

* **运行状况检查**（通常是定制 HTTP 端点）可帮助编排器（如 Kubernetes 或 Cloud Foundry）执行自动化操作来维护整体系统运行状况。
* **度量值**是按时间间隔收集到的数据，这些数据用数字表示成时间序列。数字时间序列数据易于存储和查询，有助于查找历史趋势。在较长的时间段内，数字数据可以压缩为较粗颗粒度的聚集，例如每日或每周。
* **日志条目**表示独立事件。日志条目对于调试非常重要，因为条目中通常包含堆栈跟踪和其他上下文信息，可以帮助识别所观察到的故障的根本原因。
* **分布式请求或端到端跟踪**捕获请求在整个系统中的端到端流程。跟踪本质上是捕获服务（请求所涉及的服务）之间的关系，以及在整个系统中工作的结构（同步或异步处理、衍生或顺承关系)。

## 遥测
{: #telemetry}

云本机应用程序依赖于环境进行*遥测*，遥测是自动收集数据并将数据传输到集中位置以供后续分析的方法。十二要素之一强调了遥测，该要素指出：将日志视为事件流，并扩展到微服务生成的所有数据，以确保可以观察到该微服务。

Kubernetes 有一些内置的遥测功能（如 Heapster），但遥测更有可能是通过与 Kubernetes 控制平面集成的其他系统提供的。例如，Istio 的两个组件 Mixer 和 Envoy 可一起使用，以透明方式[从部署的应用程序中收集遥测](https://istio.io/docs/concepts/policies-and-telemetry/){: new_window} ![外部链接图标](../icons/launch-glyph.svg "外部链接图标")。

发生的故障不再是具有破坏性的罕见问题。将单一应用程序分解成微服务可将更多主线路路径推送到网络上，从而增加等待时间和其他网络问题的影响。请求还会到达出于诸多原因而尚未准备好工作的进程。如果服务的资源不足，那么会自动重新启动服务，并且容错策略允许系统作为整体保持正常运行。对单个故障的手动干预在这种类型的环境中并不是很有用或不可行。

## 监视
{: #monitoring}

可观察性和遥测的概念帮助重点说明了在大规模分布式系统中监视云本机应用程序的方式上的一些重大差异。请记住，云本机环境中的进程是瞬态的。十二要素中有三个要素（进程、并行性和可处置性）强调了这一点。预先分配的长时间运行的单一进程被许多短时间运行的进程替代或包围，这些短时间运行的进程根据负载启动和停止，以进行水平伸缩，或者在进程无法正常运行时启动和停止。如果必须收集数据并将其持久存储在其他位置以防止在创建和销毁进程（容器）时丢失这些数据，遥测至关重要。此外，由于合规性原因，通常也需要遥测。 

出于上述所有原因，监视的重点变为：监视系统的总体状态，而不是监视资源（单个进程或单个机器）的行为和运行状况。每个单独的服务都会生成数据，用于填充到此聚集视图中。

## 跟踪、日志记录和度量值
{: #trace-log-metrics}

:FIXME -- 根据主题摘要，重新描述比较:

开发者希望显式输出某些消息以供某人查看时，可使用日志记录。日志记录直接编码到 Java 类中，包括传递相关变量的值。发生问题时，日志可用于调试目的，以显示发生故障的位置，例如抛出的异常的堆栈跟踪。可以使用 *Kibana* 来查看多个 pod/微服务中此类日志的联合视图。

跟踪会自动执行，因此开发者无需执行操作。例如，可以将 Liberty 配置为每当调用任何附 JAX-RS 注释的方法时，都将跟踪记录发送到符合 Open Tracing 的跟踪服务器。这样，您就有了审计记录，其中记录了调用内容、调用时间、调用者以及所用时间。您还可以通过向跟踪的此类方法添加 Open Tracing 注释来扩充该跟踪，如包含有关在代码中已调用的专用方法的信息。 

可以使用 *Zipkin* 或 *Jaeger* 等工具来显示多个 pod/微服务中跟踪的联合视图。*服务网*还可以自动跟踪通过容器的侧柜传递的调用。  

度量值用于跟踪聚集值。例如，不用费力通过跟踪或日志来查看某人创建投资组合的频率，您可以改为使其成为定制计数器度量值。可以对部署进行标注，以便 *Prometheus* 对其进行“提取”，例如定期点击 pod 上的 /metrics URI。然后，可以使用类似 *Grafana* 的工具来获取多个 pod/微服务中度量值的联合视图。

可以查看跟踪以了解“此方法已调用”。但您需要查看日志记录以了解“这就是调用该方法时其中发生的情况”。此外，您需要查看度量值以了解“其调用次数”。通常，跟踪是隐式的，无需开发者执行任何工作就能自动执行。而日志记录是显式的，需要开发者进行编码，以发送可能与问题事后分析相关的信息。度量值也是显式的，您需要向代码的相应方法添加注释（虽然程序员通常无需执行任何工作就能使用低级别缺省度量值，如用于内存使用情况、CPU 使用情况、线程计数的度量值）。

通常，度量值对于分析很有用，而日志记录对于确定问题更有用，跟踪则在了解从微服务到微服务的控制流方面更有用。
