---

copyright:
  years: 2019
lastupdated: "2019-02-10"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 运行状况检查
{: #healthcheck}

运行状况检查在自动化系统内提供了一种简单的机制，用于检查单个实例的运行状态。然后，系统通过执行操作（例如，替换失败的实例，更新路由表或将生成的运行状况传递给用户）来响应这些运行状况检查事件。
{:shortdesc}

Kubernetes 定义了两个完整机制来检查容器运行状况：

* 就绪性探测器用于指示进程能否处理请求（可否路由）。Kubernetes 不会将工作路由到未通过就绪性探测器测试的容器。如果服务尚未完成初始化，或者服务正忙、超负荷或无法处理请求，那么就绪性探测器应该会失败。
* 活性探测器用于指示是否应该重新启动进程。Kubernetes 会停止并重新启动未通过活性探测器测试的容器，以确保终止并替换处于失效状态的 Pod。如果服务处于不可恢复状态（例如，发生内存不足情况），那么活性探测器应该会失败。通过始终返回“正常”响应的简单活性检查，可以识别处于不一致状态的容器，在处理请求的进程已崩溃但容器仍在运行时会发生此情况。

就绪性和活性探测器都使用类似结构进行定义，包括时间延迟和重试时间间隔、容错时间段、超时以及探测器实现的定义。探测器可以通过运行命令、检查 TCP 端点的连接情况或执行 HTTP 调用来实现。同一探测器实现通常既可用于就绪性测试，也可用于活性测试，但时间延迟和重试时间间隔需要针对特定用途进行调整。

## 了解和应用探测器
{: #kubernetes-probes}

从根本上来说，云本机应用程序开发基于的原则是容器进程实际上确实会失败，但这些进程可以随时替换为新容器。这会在响应意外事件（例如，容器或机器故障）时发生，也会因为水平缩放和新应用程序映像应用等操作事件而发生。就绪性检查之所以重要，是因为可确保新的容器实例在路由流量之前已准备好接收工作，同时这些检查会阻止流量路由到已退出或正在销毁的实例。

未定义就绪性检查时，Kubernetes 几乎不了解容器实例是否已准备好处理流量，也不太清楚容器实例是否在容器进程启动后立即路由流量。如果不使用就绪性检查，在将工作路由到尚未准备好处理请求的实例时，应用程序遇到连接超时和连接拒绝响应的可能性更大。就绪性检查可减少客户机连接错误，但无法完全消除这些错误。

尽管在支持容器的应用程序的生命周期内，对路由目标的实例进行更改是正常的，但进程会指出用于识别的活性检查频率较低，表示的是例外情况，而非正常情况。当一个进程进入无法恢复的状态时，该进程实际上处于不工作状态。可能发生这种情况的一些示例包括内存不足情况或编程错误引起的死锁。从像这样的情境恢复的最佳方法是终止容器，这同时会导致终止当前在容器中执行的任何处理。此外，这还可能在应用程序中终止或重新启动循环，其中容器在终止并替换之前无法完全联机。

就绪性和活性探测器以不同的方式影响系统。这可以从状态转换的角度来考虑：就绪性检查的正状态为可路由，而负状态为不可路由。同样，活性检查的正状态表示容器正在正常运行，负状态表示容器不工作。容器启动时，就绪状态最初为负状态，并且仅在容器运行状况正常后才会进入正状态。活性检查启动时为正状态，并且仅当进程变为不工作时才进入负状态。

以非常激进的方式（例如，使用很短的初始延迟）配置就绪性检查几乎没什么作用，因为太早运行探测器不会使就绪性检查更改状态。另一方面，激进的活性检查（探测器触发太早）会导致状态转换更改，从而使系统比预期更早终止容器。

## 配置探测器的最佳实践
{: #probe-recommendation}

使用 HTTP 来实现运行状况探测时，请注意以下就绪性、活性的 HTTP 状态代码，以及运行状况：

|状态|就绪性|活性|
|----------|-----------------------|-----------------------|
|          |非正常，不装入|非正常，重新启动|
|正在启动|503 - 不可用|200 - 正常|
|正常运行|200 - 正常|200 - 正常|
|正在停止|503 - 不可用|200 - 正常|
|停止运行|503 - 不可用|503 - 不可用|
|出错|500 - 服务器错误|500 - 服务器错误|

运行状况检查端点不能要求授权或认证。由于不会对运行状况探测器端点实施这些保护措施，因此请将任何 HTTP 探测器实现限制为不会修改任何数据的 GET 请求。切勿返回标识环境相关细节信息（如操作系统、实现语言或软件版本）的数据，因为这些数据可用于建立攻击向量。

对于活性探测器，应该非常认真地考虑它检查的内容，因为故障会导致进程立即终止。避免仅偶尔指示失败进程的模糊度量值，例如，始终会返回 `{"status": "UP"}` 及 200 状态码的简单 HTTP 端点。处于不工作状态的大多数进程都无法通过此检查，因此将正确触发重新启动。

运行状况检查会频繁执行，这可能会导致额外的开销。没有可接受的回退时，就绪性和活性探测器应该仅测试其结果中后备服务（如数据库或其他微服务）的可行性。 对于活性探测器，仅当失败的结果会导致本地容器进入不可恢复状态时，才应包含后备检查。对于就绪性探测器，仅当本地容器失败而无法处理请求，但状况可恢复时，才应验证后备服务。

配置初始时间延迟时，就绪性探测器应该使用尽可能最小的值，而活性检查应该使用尽可能最大的时间值。例如，如果应用程序服务器通常在 30 秒内启动，那么典型的就绪性延迟为 10 秒。活性检查使用 60 秒值来确保在检查可终止状态之前，服务器启动始终可完成。

路由决策的 *periodSeconds* 属性通常配置为个位数值，前提是探测器实现是相对轻量级的。例如，在没有大量服务器端处理的情况下返回“200 正常”状态的 HTTP 探测器具有极少的处理器负载，并且可以方便地每 1 到 5 秒重复一次。

## 在 Kubernetes 中配置探测器
{: #probe-config}

在容器元素中与 Kubernetes 部署一起声明活性和就绪性探测器。这两个探测器使用相同的配置参数：

|参数|描述|
|-----------|-------------|
|*initialDelaySeconds*|创建容器后，kubelet 等待多长时间才能执行第一个探测器。|
|*periodSeconds*|kubelet 探测服务的频率。缺省值为 1。|
|*timeoutSeconds*|探测器的超时时间。缺省值和最小值都为 1。|
|*successThreshold*|探测器在失败后，必须探测成功多少次才被认定为成功。缺省值和最小值都为 1。对于活性探测器，该值必须为 1。|
|*failureThreshold*|Pod 启动但探测器失败时，Kubernetes 将尝试重新启动 Pod 多少次后才放弃（请参阅注释）。最小值为 1，缺省值为 3。|

  对于活性探测器，放弃意味着重新启动 Pod。对于就绪性探测器，放弃意味着将 Pod 标记为未就绪。
  {: note}

要避免重新启动循环，请将 `livenessProbe.initialDelaySeconds` 参数设置为长于服务初始化所需的时间，以确保安全。然后，可以对 `readinessProbe.initialDelaySeconds` 属性使用更小的值，以在服务就绪后立即将请求路由到服务。

示例配置可能类似于以下示例（请注意路径和端口值）：

```yaml
spec:
  containers:
  - name: ...
    image: ...
    readinessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 60
      timeoutSeconds: 5
    livenessProbe:
      httpGet:
        path: /liveness
        port: 8080
      initialDelaySeconds: 130
      timeoutSeconds: 10
      failureThreshold: 10
```
{: codeblock}

有关更多信息，请参阅 [Configure Liveness and Readiness Probes in Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/){: new_window} ![外部链接图标](../icons/launch-glyph.svg "外部链接图标")。
