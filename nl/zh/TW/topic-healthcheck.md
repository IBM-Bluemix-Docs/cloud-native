---

copyright:
  years: 2019
lastupdated: "2019-02-10"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 性能檢查
{: #healthcheck}

性能檢查在自動化系統內提供簡單的機制，以檢查個別實例的性能狀態。系統接著會採取動作來回應這些性能檢驗事件，例如，取代失敗的實例、更新遞送表，或與使用者溝通產生的性能狀態。
{:shortdesc}

Kubernetes 定義兩個整數機制來檢查容器的性能：

* 就緒探測用來指出處理程序是否可以處理要求（可遞送）。Kubernetes 不會將工作遞送至無法通過就緒探測的容器。如果服務尚未完成起始設定，或是忙碌、超載或無法處理要求，則就緒探測應該會失敗。
* 存活性探測用來指出是否應該重新啟動處理程序。Kubernetes 會停止並重新啟動具有失敗存活性探測的容器，以確保會終止並取代處於已廢止狀態的 Pod。如果服務處於無法回復的狀態，則存活性探測應該會失敗，例如，如果發生記憶體不足的狀況。一律傳回 OK 回應的簡單存活性檢查可以識別處於不一致狀態的容器，在處理要求的處理程序損毀但容器仍在執行時可能會發生此情況。

就緒及存活性探測都是使用類似的結構所定義，而此結構包括時間延遲及重試間隔、失敗容錯期間、逾時，以及探測實作的定義。藉由執行指令、檢查 TCP 端點的連線，或執行 HTTP 呼叫，即可實作探測。相同的探測實作通常可用於就緒或存活性目的，但是需要針對特定目的來調整時間延遲和重試間隔。

## 瞭解及套用探測
{: #kubernetes-probes}

基礎上，雲端原生應用程式開發的基礎建置在容器處理程序事實上會失敗的主體，但這些處理程序已可由新的容器取代。這種情況的發生原因在於回應容器失敗或機器故障這類非預期事件，但也在於水平調整和新應用程式映像檔推出這類作業事件。就緒檢查很重要，因為它們確保新的容器實例可在遞送資料流量之前接收工作，且相同的檢查會防止將資料流量遞送至已結束或即將毀損的實例。

未定義就緒檢查時，Kubernetes 就無法深入瞭解容器實例是否可以處理資料流量，以及是否可以在容器處理程序啟動之後立即遞送資料流量。如果沒有就緒檢查，則將工作遞送至未準備好處理要求的實例時，應用程式較可能發生連線逾時及連線拒絕回應。就緒檢查會減少，但不會完全消除用戶端連線錯誤。

即使在啟用容器的應用程式生命週期內變更實例遞送目標是正常的，處理程序會陳述要用來識別的存活性檢查較不常發生，且代表異常狀況而不是基準。處理程序進入無法回復的狀態時，該處理程序將完全無效。為何發生此情況的部分範例包括記憶體不足狀況或程式設計錯誤所造成的死鎖。從這類狀況中回復的最好方法是終止容器，但這同時也會終止容器中目前正在進行的任何處理作業。這也可能會在應用程式中建立終止或重新啟動迴圈，而這些容器在終止及取代之前都無法完全上線。

就緒及存活性探測會以不同的方式影響系統。這可視為狀態轉移，就緒檢查的正狀態為可遞送，而負狀態為無法遞送。同樣地，存活性檢查的正狀態代表正常執行的容器，而負狀態為無效。容器啟動時，就緒狀態一開始為負狀態，而且只有在容器性能良好之後才會進入正狀態。存活性檢查會以正狀態開始，而且只有在處理程序無效時才會進入負狀態。

非常積極地配置就緒檢查（例如具有低起始延遲）的效果較小，因為太快執行探測並不會導致就緒檢查變更狀態。另一方面，太快發動探測的積極存活性檢查會導致狀態轉移變更，因而導致系統比預期更快地終止容器。

## 配置探測的最佳作法
{: #probe-recommendation}

使用 HTTP 來實作性能探測時，請考量就緒、存活性及性能的下列 HTTP 狀態碼：

| 狀態     |就緒|存活性|
|----------|-----------------------|-----------------------|
|          | 非 OK 會導致不載入| 非 OK 會導致重新啟動|
| 正在啟動 | 503 - 無法使用| 200 - OK                   |
| 啟動     | 200 - OK                   | 200 - OK                   |
| 正在停止 | 503 - 無法使用| 200 - OK                   |
| 關閉     | 503 - 無法使用| 503 - 無法使用|
|發生錯誤|500 - 伺服器錯誤|500 - 伺服器錯誤|

性能檢查端點不得要求授權或鑑別。因為不會將這些保護置於性能探測端點，所以會將所有 HTTP 探測實作限制為未修改任何資料的 GET 要求。絕不要傳回可識別作業系統、實作語言或軟體版本這類環境特性的資料，因為這些資料可以用來建立攻擊向量。

存活性探測應該非常謹慎地考慮所檢查的內容，因為失敗會導致立即終止處理程序。請避免只是有時指出失敗處理程序的不明確度量值，例如，一律傳回 `{"status": "UP"}` 且具有 200 狀態碼的簡單 HTTP 端點。處於無效狀態的大部分處理程序都會讓這項檢查失敗，因此，會正確地觸發重新啟動。

以頻繁間隔發生性能檢查，這可能會導致其他額外負擔。沒有可接受的撤回時，就緒及存活性探測應該僅測試支援服務（例如其結果中的資料庫或其他微服務）的可行性。對於存活性探測，只有在不成功的結果導致本端容器進入無法復原的狀態時，才應該包括支援檢查。只有在本端容器無法處理失敗的要求時，就緒探測才應該驗證支援服務，但狀況不可回復。

配置起始時間延遲時，就緒探測應該使用最低可能值，而存活性檢查應該使用最大可能時間值。例如，如果應用程式伺服器傾向於在 30 秒內啟動，則一般就緒延遲是 10 秒。存活性檢查使用 60 秒值，以確保伺服器啟動一律在檢查是否有可終止狀態之前完成。

用於遞送決策的 *periodSeconds* 屬性一般配置為單位數值，前提是探測實作相對輕量。例如，在沒有大量伺服器端處理的情況下，傳回 200 OK 狀態的 HTTP 探測具有最小處理器負載，而且可以每 1 - 5 秒重複一次。

## 在 Kubernetes 中配置探測
{: #probe-config}

在容器元素中，宣告存活性及就緒探測與 Kubernetes 部署。兩種探測都使用相同的配置參數：

| 參數 | 說明 |
|-----------|-------------|
| *initialDelaySeconds* | kubelet 在第一次探測之前建立容器之後等待的時間量。|
| *periodSeconds* | kubelet 探測服務的頻率。預設值為 1。|
| *timeoutSeconds* | 探測逾時的速度。預設值和最小值為 1。|
| *successThreshold* | 失敗後探測必須順利完成的次數。預設和最小值為 1。存活性探測的值必須為 1。|
| *failureThreshold* | Pod 啟動且探測失敗時，Kubernetes 將在放棄之前嘗試重新啟動 Pod 的次數（請參閱附註）。最小值為 1，預設值為 3。|

  對於存活性探測，放棄表示重新啟動 Pod。對於就緒探測，放棄表示將 Pod 標示為未就緒。
  {: note}

若要避免重新啟動循環，請放心地將 `livenessProbe.initialDelaySeconds` 參數設為比服務起始設定所需更長的時間。然後，您可以使用較短的 `readinessProbe.initialDelaySeconds` 屬性值，以在服務就緒後，立即將要求遞送至服務。

配置範例可能與下列範例類似（請記下路徑和埠值）：

```yaml
spec:
  containers:
  - name: ...
    image: ...
    readinessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 60
      timeoutSeconds: 5
    livenessProbe:
      httpGet:
        path: /liveness
        port: 8080
      initialDelaySeconds: 130
      timeoutSeconds: 10
      failureThreshold: 10
```
{: codeblock}

如需相關資訊，請參閱[在 Kubernetes 中配置存活性及就緒探測](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/){: new_window} ![外部鏈結圖示](../icons/launch-glyph.svg "外部鏈結圖示")。
