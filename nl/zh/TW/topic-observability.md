---

copyright:
  years: 2019
lastupdated: "2019-07-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 觀察、遙測及監視
{: #observability-cn}

隨著轉變為雲端原生，監視會有文化上的改變。雖然內部部署及雲端原生環境中的應用程式都預期具有高可用性，並且具有失敗復原力，但用來實現這些目標的方法不同。因此，監視的目的會轉變：監視是為了管理失敗，而不是為了避免失敗。
{:shortdesc}

在內部部署環境中，基礎架構和中介軟體是根據計劃性容量和高可用性型樣（例如，主動-主動或主動-被動）所佈建。在此環境中，非預期的失敗可能很複雜，需要大量的工作量才能判斷和回復問題。外部監視是由檢查資源使用率的代理程式所執行，以避免不明的失敗類別。例如，請考量調整 Java 應用程式的資料堆大小、逾時及記憶體回收原則。

雲端原生應用程式由獨立微服務與必要的支援服務所組成。即使雲端原生應用程式必須整體保持可用並繼續運作，也會啟動或停止個別服務實例，以調整容量需求或回復失敗。 

## 觀察
{: #observability}

監視此流動式系統需要每個參與者都是*可觀察的*。每個實體都必須產生適當的資料以支援自動化問題偵測和警示、在必要時手動除錯，以及分析系統性能（歷程趨勢和分析）。

服務應該產生哪些可觀察的資料類型？

* **性能檢查**（通常是自訂 HTTP 端點）可協助 Kubernetes 或 Cloud Foundry 這類編排器執行自動化動作來維護整體系統性能。
* **度量值**是時間序列中依間隔收集之資料的數值表示法。數值時間序列資料容易儲存及查詢，這在尋找歷程趨勢時會很有用。在較長的一段時間之後，可以將數值資料壓縮為較不精細的彙總（例如，每日或每週）。
* **日誌項目**代表離散事件。日誌項目對於除錯而言很重要，因為它們通常包括堆疊追蹤和其他環境定義資訊，這些資訊有助於識別觀察到的失敗的主要原因。
* **分散式、要求或端對端追蹤**可透過系統擷取要求的端對端流程。追蹤基本上會擷取服務（要求所觸及的服務）之間的關係，以及通過系統（同步或非同步處理、子項或後續關係）的工作結構。

## 遙測
{: #telemetry}

雲端原生應用程式根據*遙測* 環境，這樣會自動收集資料，並將資料傳輸至集中位置，以進行後續分析。十二個因素中的其中一個強調了這一點，此因素會將日誌視為事件串流，並延伸至微服務所產生的所有資料，以確保可以觀察到它。

Kubernetes 具有一些內建遙測功能（例如 Heapster），但最可能由其他與 Kubernetes 控制平面整合的系統提供遙測。例如，Mixer 和 Envoy 這兩個 Istio 元件一起運作，可明確地[從已部署的應用程式收集遙測](https://istio.io/docs/concepts/policies-and-telemetry/){: new_window} ![外部鏈結圖示](../icons/launch-glyph.svg "外部鏈結圖示")。

失敗不再是罕見且造成干擾的發生事件。將整合型應用程式分為數個微服務會將較多的主線路徑推送至網路，進而增加延遲和其他網路問題的影響。要求也會呼叫因多種原因而未備妥的處理程序。如果服務耗盡資源，且容錯策略容許系統整體持續運作，則會自動重新啟動該服務。在這類型環境中，個別失敗的人為介入不怎麼有用或不可行。

## 監視
{: #monitoring}

觀察及遙測的概念有助於強調顯示如何監視大規模分散式系統中雲端原生應用程式的一些重要差異。請記住，雲端原生環境中的處理程序是暫時性。十二個因素中的其中三個（處理程序、並行性及可移除）強調了這一點。預先配置、長時間執行、整合型處理程序已取代或替代為多個短期處理程序，這些短期處理程序會啟動及停止來回應水平調整的負載，或者它們是否無法正常運作。如果必須收集並持續保存資料以防止在建立及破壞處理程序（容器）時遺失，則遙測非常重要。基於相符性原因，通常也需要遙測。 

對於先前所述的所有原因，監視會變更焦點：會整體監視系統的狀態，而不是監視資源（個別處理程序或個別機器）的行為和性能。每個個別服務都會產生提供給此聚集視圖的資料。

## 追蹤、記載與度量值
{: #trace-log-metrics}

:FIXME -- 根據主題摘要，重新描述比較：

開發人員希望明確輸出某些訊息以供某人查看時，可使用記載。它會直接編碼為 Java 類別，包括傳遞相關變數的值。發生問題時，日誌可用於除錯目的，以顯示發生失敗的位置，例如擲出的異常狀況的堆疊追蹤。您可以使用 *Kibana* 來檢視 Pod/微服務中這類日誌的聯合視圖。

追蹤會自動執行，因此開發人員不需要執行動作。例如，可以將 Liberty 配置為每當呼叫任何附 JAX-RS 註釋的方法時，都將追蹤記錄傳送到符合 Open Tracing 的追蹤伺服器。這樣，您就有了審核記錄，其中記錄呼叫內容、呼叫時間、呼叫者以及所用時間。您還可以向追蹤的這類方法新增 Open Tracing 註釋來擴增該追蹤，例如包括程式碼中已呼叫的專用方法的相關資訊。 

您可以使用 *Zipkin* 或 *Jaeger* 這類工具來顯示 Pod/微服務中追蹤的聯合視圖。*服務網格* 也可以自動追蹤透過容器的 Sidecar 所傳遞的呼叫。  

度量值用於追蹤聚集值。例如，不用費力透過追蹤或日誌來查看某人建立投資組合的頻率，您可以改為使其成為自訂計數器度量值。您可以標示部署，讓 *Prometheus* 對其進行「提取」，例如定期點擊 Pod 上的 /metrics URI。然後，您可以使用 *Grafana* 這類工具來取得 Pod/微服務中度量值的聯合視圖。

您可以查看追蹤以瞭解「此方法已呼叫」。但您需要查看記載才能瞭解「這就是呼叫該方法時其中發生的情況」。您還需要查看度量值以瞭解「其呼叫次數」。通常，追蹤是隱含的，不需要開發人員執行任何工作就能自動執行。而記載是明確的，需要開發人員進行編碼，才能傳送可能與問題事後分析相關的參考資訊。度量值也是明確的，您需要向程式碼的適當方法新增註釋（雖然程式設計師通常不需要執行任何工作就能使用低階預設度量值，例如用於記憶體用量、CPU 用量、執行緒計數的度量值）。

通常，度量值對於分析很有用，而記載對於確定問題更有用，追蹤則在瞭解從微服務到微服務的控制流程方面更有用。
