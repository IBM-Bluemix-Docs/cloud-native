---

copyright:
  years: 2019
lastupdated: "2019-07-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 관찰 가능성, 원격 측정 및 모니터링
{: #observability-cn}

모니터링과 관련하여 클라우드 네이티브로의 전환과 함께 문화적 변화가 일어나고 있습니다. 온프레미스와 클라우드 네이티브 환경 모두에서 애플리케이션의 고가용성과 복구 성능이 뛰어나지만 이러한 목표를 달성하는 데 사용되는 방법은 다릅니다. 결과적으로 모니터링의 목적이 변화하고 있습니다. 실패를 방지하기 위해서가 아니라 오류를 관리하기 위해 모니터합니다. 
{:shortdesc}

온프레미스 환경에서는 인프라 및 미들웨어가 계획된 용량 및 고가용성 패턴(예: 능동-능동 또는 능동-수동)을 기반으로 프로비저닝됩니다. 이 환경에서는 예기치 않은 장애가 복잡할 수 있으므로 문제를 파악하고 복구하는 데 상당한 노력이 필요합니다. 외부 모니터링은 알려진 장애 클래스를 방지하기 위해 리소스 활용도를 검사하는 에이전트에서 수행합니다. 예를 들어 Java 애플리케이션에 대한 힙 크기, 시간 초과 및 가비지 콜렉션 정책의 조정을 고려해야 합니다.

클라우드 네이티브 애플리케이션은 독립적인 마이크로서비스와 필수 지원 서비스로 구성됩니다. 전체적으로 클라우드 네이티브 애플리케이션을 사용할 수 있어야 하고 기능을 계속 수행하더라도 용량 요구사항을 조정하거나 장애로부터 복구하기 위해 개별 서비스 인스턴스가 시작되거나 중지됩니다. 

## 관찰 가능성
{: #observability}

이 유동 시스템을 모니터하려면 각 참여 요소가 *관찰 가능(observable)*해야 합니다. 각 엔티티는 자동화된 문제점 발견 및 경보, 필요한 경우 수동 디버깅 및 시스템 상태 분석(히스토리 경향 및 분석)을 지원하기 위해 적절한 데이터를 생성해야 합니다.

서비스가 관찰할 수 있도록 어떤 종류의 데이터를 생성해야 합니까?

* **상태 검사**(대개 사용자 정의 HTTP 엔드포인트)는 Kubernetes 또는 Cloud Foundry와 같은 오케스트레이터가 전체 시스템 상태를 유지보수하기 위해 자동화된 조치를 수행하도록 지원합니다.
* **메트릭**은 간격에 따라 수집된 데이터를 시계열로 숫자로 표시한 것입니다. 숫자 시계열 데이터는 저장 및 조회가 용이하여 히스토리 경향을 찾을 때 도움이 됩니다. 더 오랜 시간 동안 숫자 데이터는 예를 들어 매일 또는 매주 더 세분화된 집계로 압축될 수 있습니다.
* **로그 항목**은 개별 이벤트를 나타냅니다. 로그 항목은 종종 스택 추적 및 관찰된 장애의 근본 원인을 식별하는 데 도움이 되는 기타 상황 정보를 포함하므로 디버깅에 필수적입니다.
* **분산, 요청 또는 엔드 투 엔드 추적**은 시스템을 통한 요청의 엔드-투-엔드 플로우를 캡처합니다. 추적은 기본적으로 서비스(요청이 접촉한 서비스)와 시스템을 통한 작업 구조(동기 또는 비동기 처리, 하위 또는 후속 관계) 간의 관계를 모두 캡처합니다.

## 텔레메트리
{: #telemetry}

클라우드 네이티브 애플리케이션은 후속 분석을 위해 중앙 집중화된 위치로 데이터를 자동으로 수집하고 전송하는 *텔레메트리(telemetry)*용 환경에 의존해야 합니다. 이는 로그를 이벤트 스트림으로 처리한다는 12가지 요소 중 하나에서 강조되며, 이를 관찰할 수 있도록 마이크로서비스에서 생성하는 모든 데이터로 확장됩니다.

Kubernetes는 Heapster와 같은 일부 기본 제공 텔레메트리 기능을 가지고 있지만, 텔레메트리는 Kubernetes 제어판과 통합된 다른 시스템에서 제공될 가능성이 높습니다. 예를 들어 Istio의 두 컴포넌트인 Mixer와 Envoy는 연동하여 [배치된 애플리케이션에서 텔레메트리를 투명하게 수집](https://istio.io/docs/concepts/policies-and-telemetry/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘")합니다.

장애는 더 이상 드물지만 운영을 중단시키는 것이 아닙니다. 단일 애플리케이션을 마이크로서비스로 세분화하면 더 많은 메인라인 경로가 네트워크로 이동하게 되어 대기 시간 및 기타 네트워크 문제의 영향이 증가합니다. 요청은 또한 여러 가지 이유로 인해 작업을 수행할 준비가 되지 않은 프로세스에도 도달합니다. 서비스는 리소스가 부족하면 자동으로 재시작되며, 결함 허용 전략을 통해 시스템 전체가 계속 작동합니다. 개별 장애에 대한 수동 개입은 이러한 환경에서 유용하거나 실현 가능하지 않습니다.

## 모니터링
{: #monitoring}

관찰 가능성과 텔레메트리의 개념은 대규모 분산 시스템에서 클라우드 네이티브 애플리케이션을 모니터하는 방법의 몇 가지 중요한 차이를 강조하는 데 도움이 됩니다. 클라우드 네이티브 환경의 프로세스는 일시적입니다. 12가지 요인 중 3가지(프로세스, 동시성 및 일회성)가 이 점을 강조합니다. 사전 할당되고 오래 실행되고 있는 단일 프로세스에서는 수평적 확장을 위한 로드 또는 제대로 작동하지 않는 로드에 대응하여 시작 및 중지되는 수명 주기가 훨씬 짧은 많은 프로세스로 대체되거나 이에 포함됩니다. 텔레메트리는 프로세스(컨테이너)가 생성 및 파괴될 때 데이터가 손실되는 것을 방지하기 위해 데이터를 수집하고 다른 곳에 유지해야 하는 경우 중요합니다. 규제 준수를 위해 텔레메트리가 필요한 경우가 많습니다. 

앞에서 설명한 내용의 모든 이유는 모니터링의 초점이 이동한다는 것입니다. 리소스(개별 프로세스 또는 개별 시스템)의 동작 및 상태를 모니터하는 것이 아니라 시스템 상태를 전체적으로 모니터합니다. 각 개별 서비스는 생성된 데이터를 이러한 집계된 보기에 전송합니다.

## 추적 대 로깅 대 메트릭
{: #trace-log-metrics}

:FIXME -- 주제 요약으로서 비교 정리:

로깅은 개발자가 사용자가 볼 수 있는 메시지를 명시적으로 출력하려고 할 때 사용됩니다. 관련 변수 값을 따라 전달하는 것을 포함하여 Java 클래스로 직접 코딩됩니다. 문제점이 발생하는 경우, 로그는 오류가 발생한 위치(예: 발생한 예외에 대한 스택 추적 등)를 표시하며 디버깅 목적에 유용합니다. *Kibana*를 사용하여 팟/마이크로서비스를 교차하여 해당 로그의 연합 보기를 볼 수 있습니다.

추적이 자동으로 발생하므로 개발자가 조치를 수행하지 않습니다. 예를 들어, JAX-RS 어노테이션 메소드가 호출될 때마다 추적 레코드를 Open Tracing 호환 추적 서버에 전송하도록 Liberty를 구성할 수 있습니다. 이 방식으로 언제, 누구에 의해 호출되었으며 시간이 얼마나 걸렸는지에 대한 감사 레코드를 가질 수 있습니다. 또한 추적되는 해당 메소드에 Open Tracing 어노테이션을 추가하여 코드에서 어떤 사설 메소드가 호출되었는지에 대한 정보를 포함하여 추적을 보강할 수 있습니다. 

*Zipkin* 또는 *Jaeger*와 같은 도구를 사용하여 팟/마이크로서비스를 교차하는 연합 보기를 표시할 수 있습니다. 또한, *서비스 메쉬*는 컨테이너의 사이드 카를 통해 전달되는 호출의 자동 추적을 제공할 수 있습니다.  

메트릭은 집계 값을 추적하는 데 사용됩니다. 추적 또는 로그를 통해 사용자가 포트폴리오를 작성하는 빈도를 찾는 대신 사용자 정의 카운터 메트릭을 작성할 수 있습니다. 정기적으로 팟(Pod)에 /metrics URI를 추가하는 것과 같이 *Prometheus*에 의해 스크레이핑되도록 배치에 레이블을 지정할 수 있습니다. 그런 다음 *Grafana*와 같은 도구를 사용하여 팟/마이크로서비스를 교차하는 연합 메트릭 보기를 얻을 수 있습니다.

추적을 보면 "이 메소드가 호출됨"을 알 수 있습니다. 그러나 로깅을 보면 "메소드가 호출될 때 내부에서 발생한 일"을 알 수 있습니다. 또한 메트릭을 보면 "호출된 횟수"를 알 수 있습니다. 일반적으로 추적은 암시적이며 개발자의 노력 없이 자동으로 발생합니다. 로깅은 명시적이지만 개발자가 문제점이 발생한 이후의 분석과 관련된 정보를 전송하는 코딩을 작성해야 합니다. 메트릭 또한 코드의 적절한 메소드에 어노테이션을 추가해야 하는 한 명시적입니다. 단, 메모리 사용량, CPU 사용량, 스레드 개수와 같이 프로그래머의 노력이 필요 없는 하위 레벨의 기본 메트릭도 종종 있습니다.

일반적으로, 메트릭은 분석에 유용한 반면, 로깅은 문제점 판별 목적에 더 유용하며 추적은 마이크로서비스에서 마이크로서비스로의 제어 플로우를 이해하는 데 더 유용합니다.
