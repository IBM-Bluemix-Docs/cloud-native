---

copyright:
  years: 2019
lastupdated: "2019-02-10"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 상태 검사
{: #healthcheck}

상태 검사(health check)는 자동화된 시스템 내의 단순 메커니즘을 제공하여 개별 인스턴스의 상태를 검사합니다. 그런 다음 시스템은 실패한 인스턴스 대체, 라우팅 테이블 업데이트 또는 결과 상태를 사용자에게 전달하는 등의 조치를 수행하여 이러한 시스템 상태 검사 이벤트에 응답합니다.
{:shortdesc}

Kubernetes는 컨테이너의 상태를 확인하는 데 필요한 2개의 통합 메커니즘을 정의합니다.

* 준비 상태 프로브(readiness probe)는 프로세스가 요청을 처리할 수 있는지(라우트 가능) 여부를 표시하는 데 사용됩니다. Kubernetes는 실패한 준비 상태 프로브가 있는 컨테이너로 작업을 라우팅하지 않습니다. 서비스가 초기화를 완료하지 않았거나 사용 중이거나 과부하되었거나 요청을 처리할 수 없는 경우에는 준비 상태 프로브가 실패합니다.
* 활성 상태 프로브(liveness probe)는 프로세스를 다시 시작해야 하는지 여부를 표시하는 데 사용됩니다. Kubernetes는 손상된 상태의 팟(Pod)이 종료되고 교체되었는지를 확인하기 위해 실패한 활성 상태 프로브가 있는 컨테이너를 중지하고 다시 시작합니다. 예를 들어 메모리 부족 상태가 발생하는 등 서비스가 복구할 수 없는 상태인 경우 활성 상태 프로브가 실패합니다. 항상 OK 응답을 리턴하는 간단한 활성 상태 검사에서 일관되지 않은 상태의 컨테이너를 식별할 수 있습니다. 이러한 컨테이너는 프로세스 제공 요청이 충돌했지만 컨테이너가 여전히 실행 중일 때 발생할 수 있습니다.

준비 상태 및 활성 상태 프로브는 모두 시간 지연 및 재시도 간격, 실패 허용 기간, 제한시간 초과 및 프로브 구현의 정의를 포함하는 유사한 구조를 사용하여 정의됩니다. 프로브는 명령을 실행하고, 연결을 위해 TCP 엔드포인트를 검사하거나 HTTP 호출을 수행하여 구현될 수 있습니다. 동일한 프로브 구현을 준비 상태 또는 활성 상태 모두를 위해 사용할 수 있는 경우가 많지만, 특정 목적에 맞게 시간 지연 및 재시도 간격을 조정할 필요가 있습니다.

## 프로브 이해 및 적용
{: #kubernetes-probes}

기본적으로 클라우드 네이티브 애플리케이션 개발은 컨테이너 프로세스가 실제로 실패한다는 원칙에 따라 수행되지만 이러한 프로세스는 새 컨테이너로 쉽게 대체됩니다. 이는 컨테이너 또는 시스템 오류와 같은 예기치 않은 이벤트에 대한 응답일 뿐만 아니라 수평적 확장 및 새 애플리케이션 이미지 원격 설치와 같은 운영 이벤트로 인해 발생합니다. 준비 상태 검사는 새 컨테이너 인스턴스가 라우팅 트래픽 이전에 작업을 수신할 준비가 되었는지 확인하고 동일한 검사에서 종료되었거나 삭제 중인 인스턴스로 트래픽이 라우트되는 것을 방지하기 때문에 중요합니다.

준비 상태 검사가 정의되지 않은 경우, Kubernetes는 컨테이너 인스턴스가 트래픽을 처리할 준비가 되었는지 여부를 거의 파악하지 못하고 컨테이너 프로세스가 시작된 후 즉시 트래픽을 라우팅합니다. 준비 상태 검사가 없으면 작업이 요청을 처리할 준비가 되지 않은 인스턴스로 라우팅될 때 애플리케이션은 연결 시간초과 및 연결 거부 응답을 경험할 가능성이 높습니다. 준비 상태 검사는 클라이언트 연결 오류를 줄이지만 완전히 제거하지는 않습니다.

인스턴스 라우팅 대상에 대한 변경은 컨테이너 사용 애플리케이션의 라이프사이클 내에서 일반적이지만, 프로세스는 식별하려는 활성 상태 검사가 빈도가 더 낮고 표준이 아닌 예외를 나타냄을 명시합니다. 프로세스가 복구 불가능한 상태가 되면 해당 프로세스는 효과적으로 작동하지 않습니다. 이러한 상황이 발생하는 이유에 대한 몇 가지 예로는 메모리 부족 또는 프로그래밍 오류로 인한 교착 상태가 있습니다. 이와 같은 상황에서 복구하는 가장 좋은 방법은 컨테이너를 종료하는 것이며, 컨테이너에서 현재 진행 중인 모든 처리가 종료됩니다. 이로 인해 애플리케이션에서 종료 또는 재시작 루프가 발생할 수 있습니다. 이 경우 컨테이너는 종료 및 교체 전에 완전히 온라인 상태가 될 수 없습니다.

준비 상태 및 활성 상태 프로브는 시스템에 다른 방식으로 영향을 줍니다. 이는 준비 상태 검사의 긍정적 상태가 라우팅 가능이고 부정적 상태가 라우팅 불가능인, 상태 전이의 관점에서 생각할 수 있습니다. 마찬가지로, 활성 상태 검사의 긍정적 상태는 컨테이너가 정상적으로 실행되는 것이고 부정적 상태는 작동하지 않는 것입니다. 컨테이너가 시작되면 준비 상태의 상태는 처음에 부정적이며 컨테이너가 정상인 경우에만 긍정적 상태가 됩니다. 활성 상태 검사는 긍정적 상태에서 시작되며 프로세스가 작동하지 않는 경우에만 부정적 상태가 됩니다.

프로브를 너무 빨리 실행해도 준비 상태 검사의 상태가 변경되지 않기 때문에 초기 지연 시간을 짧게 하는 등 매우 적극적으로 준비 상태 검사를 구성해도 거의 영향을 주지 않습니다. 반면, 프로브가 너무 빨리 시작되는 적극적인 상태 검사에서는 상태 전환이 변경되어 시스템이 의도한 것보다 빨리 컨테이너를 종료합니다.

## 프로브 구성을 위한 우수 사례
{: #probe-recommendation}

HTTP를 사용하여 상태 프로브를 구현할 때에는 준비 상태, 활성 상태 및 상태(health)에 대해 다음과 같은 HTTP 상태 코드를 고려하십시오.

| 상태    |  준비 상태            |  활성 상태             |
|----------|-----------------------|-----------------------|
|          | OK가 아니면 로드하지 않음 | OK가 아니면 다시 시작 |
| 시작 중 | 503 - 사용 불가능     | 200 - OK              |
| 작동       | 200 - OK              | 200 - OK              |
| 중지 중 | 503 - 사용 불가능     | 200 - OK              |
| 중지     | 503 - 사용 불가능     | 503 - 사용 불가능     |
| 오류 발생  | 500 - 서버 오류    | 500 - 서버 오류    |

상태 검사 엔드포인트에 권한 또는 인증이 필요하지 않아야 합니다. 이러한 보호는 상태 프로브 엔드포인트에 적용되지 않으므로 데이터를 수정하지 않는 GET 요청으로 HTTP 프로브 구현을 제한합니다. 운영 체제, 구현 언어 또는 소프트웨어 버전과 같이 환경에 대한 특정 정보를 식별하는 데이터를 리턴하지 마십시오. 이러한 데이터는 공격 벡터를 설정하는 데 사용될 수 있습니다.

활성 상태 프로브는 검사 대상에 매우 신중해야 합니다. 실패하면 프로세스가 즉시 종료되기 때문입니다. 200 상태 코드와 함께 `{"status": "UP"}`을 항상 리턴하는 간단한 HTTP 엔드포인트와 같이 때때로 실패 프로세스만 나타내는 모호한 메트릭은 사용하지 마십시오. 작동하지 않는 대부분의 프로세스는 이 검사에 실패하므로 다시 시작을 올바르게 트리거합니다.

상태 검사는 빈번한 간격으로 발생하며, 이로 인해 추가 오버헤드가 발생할 수 있습니다. 준비 상태 및 활성 상태 프로브는 허용 가능한 대체 조치가 없을 때 데이터베이스 또는 기타 마이크로서비스와 같은 지원 서비스의 실행 가능성만 테스트해야 합니다. 활성 상태 프로브의 경우, 성공적이지 않은 결과로 인해 로컬 컨테이너가 복구 불가능한 상태가 되는 경우에만 지원 검사가 포함되어야 합니다. 준비 상태 프로브는 로컬 컨테이너가 실패하는 경우 요청을 처리할 수 없지만 상태가 복구 가능한 경우에만 지원 서비스를 확인해야 합니다.

초기 시간 지연을 구성할 때 준비 상태 프로브는 가능한 가장 낮은 값을 사용해야 하며 활성 상태 검사에서는 가능한 가장 큰 시간 값을 사용해야 합니다. 예를 들어 애플리케이션 서버가 30초 후에 시작하는 경향이 있는 경우 일반적인 준비 상태 지연 시간은 10초입니다. 활성 상태 검사는 종료 가능한 상태를 확인하기 전에 항상 서버 시작이 완료되도록 60초 값을 사용합니다.

라우팅 결정을 위한 *periodSeconds* 속성은 프로브 구현이 상대적으로 경량이라면 일반적으로 한 자리 값으로 구성됩니다. 예를 들어, 실제 서버측 처리 없이 200 OK 상태를 리턴하는 HTTP 프로브는 최소한의 프로세서 로드를 가지며 1 - 5초마다 쉽게 반복할 수 있습니다.

## Kubernetes에서 프로브 구성
{: #probe-config}

컨테이너 요소에 Kubernetes 배치와 함께 활성 상태 및 준비 상태 프로브를 선언합니다. 두 프로브 모두 동일한 구성 매개변수를 사용합니다.

|매개변수 |설명 |
|-----------|-------------|
| *initialDelaySeconds* | 첫 번째 프로브 전에 컨테이너가 작성된 후에 kubelet가 대기하는 시간. |
| *periodSeconds* | kubelet이 서비스를 프로브하는 주기. 기본값은 1입니다. |
| *timeoutSeconds* | 프로브의 제한시간. 기본 및 최소값은 1초입니다. |
| *successThreshold* | 실패 후 프로브가 성공해야 하는 횟수. 기본 및 최소값은 1입니다. 값은 활성 상태 프로브에 대해 1이어야 합니다. |
| *failureThreshold* | Kubernetes가 팟(Pod)이 시작되고 프로브가 실패할 때 포기하기 전에 팟(Pod)을 다시 시작하려고 시도하는 횟수(참고 참조). 최소값은 1이고 기본값은 3입니다. |

  활성 상태 프로브의 경우 포기하는 것은 팟(Pod)을 다시 시작하는 것을 의미합니다. 준비 상태 프로브의 경우 포기하는 것은 팟(Pod)을 준비되지 않은 것으로 표시하는 것을 의미합니다.
  {: note}

다시 시작 주기를 피하려면, `livenessProbe.initialDelaySeconds` 매개변수를 서비스가 초기화되는 데 걸리는 시간보다 안전하게 길게 설정합니다. 그런 다음 `readinessProbe.initialDelaySeconds` 속성에 대해 더 짧은 값을 사용하여 요청이 준비되는 즉시 서비스로 라우팅할 수 있습니다.

예제 구성은 다음 예제와 유사할 수 있습니다(경로 및 포트 값 참조).

```yaml
spec:
  containers:
  - name: ...
    image: ...
    readinessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 60
      timeoutSeconds: 5
    livenessProbe:
      httpGet:
        path: /liveness
        port: 8080
      initialDelaySeconds: 130
      timeoutSeconds: 10
      failureThreshold: 10
```
{: codeblock}

자세한 정보는 [Kubernetes에서 활성 상태 및 준비 상태 프로브 구성](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘")을 참조하십시오.
