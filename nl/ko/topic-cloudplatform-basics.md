---

copyright:
  years: 2019
lastupdated: "2019-02-18"

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}
{:important: .important}

# 클라우드 플랫폼 개념
{: #platform}

이 절에서는 개발자가 컨테이너, Kubernetes, Helm 및 Istio를 사용하여 클라우드 네이티브 애플리케이션을 빌드할 때 상호 작용하는 핵심 기술과 개념에 대한 간단한 개요를 제공합니다.
{:shortdesc}

## 컨테이너
{: #containers}

컨테이너(container)는 애플리케이션 및 모든 종속 항목을 단일의 자체 포함 단위로 패키화하는 표준 메커니즘입니다. 컨테이너는 이식성 문제를 해결합니다. 컨테이너 아티팩트(이미지)는 애플리케이션이 실행해야 하는 모든 것이 올바른 위치에 있는지 확인하고 컨테이너 엔진은 효율적이고 안전하며 보안 적용된 방법으로 컨테이너를 분리된 프로세스로 실행하는 데 중점을 둘 수 있습니다.  

일반적으로 컨테이너 이미지는 `Dockerfile`에 정의된 지시사항 목록에서 빌드됩니다. 컨테이너 이미지는 거의 항상 다른 컨테이너 이미지에서 빌드됩니다 (기본적으로, 알려진 이전 상태의 지시사항은 계속됨). 다음 스니펫을 사용하여 사용자 고유의 Open Liberty 이미지를 작성할 수 있습니다. 예를 들어, 다음과 같습니다.

```yaml
FROM open-liberty:kernel
COPY server.xml /config/
```
{: codeblock}

이미지가 빌드된 후에는 실행할 수 있습니다. 컨테이너 실행 엔진(예: Docker 또는 [containerd](https://containerd.io/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘"))은 이미지 정의를 수행하고 정의된 시작점을 호스트 운영 체제의 맨 위에 직접 리소스 분리된 프로세스로 실행하여 가상 머신의 오버헤드를 제거합니다. 

컨테이너 이미지는 *레지스트리(registry)*에 저장됩니다. 가장 잘 알려진 것은 공용 Docker Hub 레지스트리입니다. 그러나 보다 일반적으로는 액세스 제어 컨테이너 레지스트리, 예를 들어 인프라 및 CI/CD 파이프라인과 더 밀접하게 연관되어 있는 {{site.data.keyword.registryshort_notm}}에서 이미지를 가져오고 내보냅니다. 

## Kubernetes
{: #kubernetes}

IBM의 클라우드 플랫폼은 컨테이너 오케스트레이션을 위해 Kubernetes를 활용합니다. 따라서 개발자는 컨테이너 기본에 대해 알고 있을 뿐 아니라 기본 명령과 배치 아티팩트를 포함한 Kubernetes의 기본 사항을 숙지하는 것이 중요합니다. 다음 표에는 몇 가지 중요한 Kubernetes 개념이 포함되어 있습니다.

| 개념     | 설명 |
|---------|-------------|
| 팟(Pod) | 단일 단위로 함께 배치되는 컨테이너의 로컬화된 그룹입니다. 팟(Pod)은 상대적으로 불변이며, 팟(Pod)의 다양한 속성들을 변경하기 위해서는 원래의 팟(Pod)을 교체해야 합니다. 일반적인 애플리케이션에는 핵심 비즈니스 로직이 포함된 하나의 컨테이너가 있으며 팟(Pod)의 세부 레벨에서 플랫폼 기능을 제공하는 추가 팟(Pod)을 선택적으로 보유합니다. |
| 배치 | 상태 비저장(stateless) 팟에 대해 반복 가능한 템플릿으로, 팟(Pod) 개념에 스케일 차원을 추가합니다. 또한, 템플리트화된 정의가 업데이트될 수 있고, 기본적인 팟(Pod) 인스턴스가 대체될 수 있습니다. Kubernetes 배치 구성은 Kubernetes 배치 제어기가 모니터하여 지정된 배치에 대한 선언된 팟(Pod) 수가 유지되는지 확인합니다. 배치는 `.yaml` 파일에 `kind: Deployment`로 표시됩니다. |
| 서비스 | 상대적으로 불안정한 팟(Pod) IP 주소 세트를 나타내는 잘 알려진 이름입니다. 서비스는 클러스터 사설 네트워크에만 존재하거나 일반적으로 클라우드 제공자 특정 로드 밸런서를 사용하여 외부에 노출될 수 있습니다. 서비스는 `.yaml` 파일에 `kind: Service`로 표시됩니다. |
| Ingress | 가상 호스팅 또는 컨텍스트 기반 라우팅을 통해 단일 네트워크 주소를 다중 서비스와 공유할 수 있는 기능을 제공합니다.  Ingress는 또한 TLS 종료와 같은 네트워크 연결 관리 활동을 수행할 수 있습니다. Ingress는 `.yaml` 파일에 `kind: Ingress`로 표시됩니다. |
| 시크릿 | 팟(Pod) 런타임에 대한 민감한 정보를 저장하고 배치 특정 정보를 컨테이너 이미지 또는 컨테이너 오케스트레이션에서 구분하는 오브젝트입니다. 시크릿은 환경 변수 또는 가상 파일 시스템 마운트를 통해 런타임 시 팟에 노출될 수 있습니다. 시크릿이 없는 경우 민감한 데이터는 컨테이너 이미지나 오케스트레이션에 저장되며, 둘 다 우발적으로 노출되거나 의도하지 않은 액세스가 발생할 가능성이 더 많아집니다. |
| ConfigMap | 배치 특정 정보를 컨테이너 오케스트레이션에서 분리한다는 점에서 시크릿과 유사한 역할을 수행합니다. 그러나 ConfigMap은 범용 구성 구조입니다. 런타임 시의 팟(Pod)의 컨테이너 및 시스템 컴포넌트에 명령행 인수, 환경 변수 및 기타 구성 아티팩트와 같은 정보를 바인드하는 데 사용됩니다. | 
{: caption="표 1. Kubernetes 개념" caption-side="bottom"}

모든 리소스들은 Kubernetes 리소스 모델 내에 정의되며, 이는 RESTful API를 통해 또는 `kubectl` 명령행으로 제출된 구성 파일들을 통해 구성될 수 있습니다.

자세한 정보는 [Kubernetes 기본](https://kubernetes.io/docs/tutorials/kubernetes-basics/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘"), [Kubernetes 오브젝트 모델](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/)![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘") 및 [`kubectl` 명령행](https://kubernetes.io/docs/reference/kubectl/overview/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘")을 참조하십시오. 

## Helm
{: #helm}

Helm은 Kubernetes를 위해 빌드된 소프트웨어를 쉽게 찾고, 공유하고, 사용할 수 있는 패키지 관리자입니다. 또한 동일한 애플리케이션을 여러 환경에 배치하는 일반 사용자에게 필요합니다. Helm은 설치 시 유효한 Kubernetes 오브젝트(YAML)를 생성하는 템플리트의 컬렉션인 *차트(chart)*를 사용합니다. 이러한 차트는 변수, 범위 오퍼레이션 및 사용자가 Kubernetes 배치 메타데이터를 유지보수하는 많은 업무를 줄여주는 기타 작업에 대한 지원을 포함하는 템플리트 언어를 사용하여 빌드됩니다.

자세한 정보는 [Helm](https://helm.sh/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘 ")을 참조하십시오.

## Istio 서비스 메쉬
{: #istio}

Istio는 마이크로서비스의 관리 및 보안을 위한 오픈 소스 플랫폼입니다. 이는 서비스 간의 통신을 관리하고 제어하는 방식을 제공하는 Kubernetes와 같은 오케스트레이터와 함께 작동합니다. 

Istio는 사이드카(sidecar) 모델을 사용하여 운영됩니다. 사이드카(Envoy 프록시)는 애플리케이션과 함께 제공되는 별도의 프로세스입니다. 사이드카는 서비스 간 모든 통신을 관리하고, 서비스가 구축된 프로그래밍 언어 또는 프레임워크와 무관하게 모든 서비스에 공통 레벨의 기능을 적용합니다. 이를 통해 Istio는 라우팅 및 보안 정책을 중앙에서 구성하는 동시에 사이드카를 통해 이러한 정책을 분산적으로 적용할 수 있는 메커니즘을 제공합니다. 

대부분의 경우 개별 프로그래밍 언어 또는 프레임워크에서 제공하는 유사한 기능 대신 Istio에서 제공하는 기능을 사용하는 것이 좋습니다. 로드 밸런싱 및 기타 라우팅 정책은 인프라에 의해 보다 일관되게 정의, 관리 및 적용됩니다.

분산 추적에서와 마찬가지로, Istio와 애플리케이션 레벨 라이브러리는 상호 보완적인 경우도 있습니다. 둘 다 함께 사용하면 운영을 개선할 수 있습니다. 분산 추적의 경우, Istio는 추적 헤더가 있는지 확인할 수 있습니다. 애플리케이션 라이브러리는 요청 간의 관계에 대한 중요한 컨텍스트를 제공합니다. Istio와 지원 라이브러리 또는 프레임워크 라이브러리를 함께 사용하면 시스템 전체에 대한 이해가 향상됩니다. 

Istio는 최고 수준에서 Kubernetes 플랫폼을 확장하여 추가적인 관리 개념, 가시성 및 보안을 제공합니다. Istio의 기능은 다음과 같은 네 가지 카테고리로 구분할 수 있습니다. 

* 트래픽 관리: 마이크로서비스 간의 트래픽을 제어하여 트래픽 분할, 장애 복구 및 카나리아(canary) 릴리스를 수행합니다. 
* 보안: 마이크로서비스 간에 강력한 ID 기반 인증, 권한 부여 및 암호화를 제공합니다. 
* 관찰 가능성: 클러스터에서 실행 중인 애플리케이션에 대한 가시성을 높이기 위해 메트릭과 로그를 수집합니다. 
* 정책: 액세스 제어, 비율 제한 및 할당량을 적용하여 애플리케이션을 보호합니다.  

자세한 정보는 [Istio의 개념](https://istio.io/docs/concepts/what-is-istio/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘")을 참조하십시오. 



